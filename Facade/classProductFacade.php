<?php

	/*
	Шаблон Facade
	Возможно, вы уже когда-то встраивали системы сторонних компаний-разработчиков в свои проекты. И независимо от того, какой это код - объектно-ориентированный или нет, он, как правило, очень сложный, длинный и непонятный. А ваш код, в свою очередь, может стать проблемой для программиста клиентского кода, которому нужно всего лишь получить доступ к нескольким функциям. Шаблон Facade - это простой способ предоставить простой и понятный интерфейс для сложных систем.


	Проблема
	Обычно в процессе проектирования системы длина ее кода, который на самом деле полезен только в пределах самой системы, постепенно увеличивается. В хорошо спроектированных системах разработчики с помощью классов определяют понятный общедоступный интерфейс и прячут поглубже внутреннее содержание системы. Но не всегда очевидно, какие части системы должны использоваться в клиентском коде, а какие лучше спрятать.
	Работая с такими подсистемами, как веб-форумы или приложения для создания галерей, вы, возможно, делали вызовы глубоко в логику кода. Если код подсистемы должен со временем меняться, а ваш код взаимодействует с ним в самых разных точках, то по мере развития подсистемы у вас возникнет серьезная проблема с поддержкой вашего кода.
	Аналогично, когда вы создаете собственные системы, имеет смысл разнести отдельные части на разные уровни. Как правило, первый уровень отвечает за логику приложения, второй - за взаимодействие с базой данных, третий - за представление данных и т.п. Вы должны стремиться поддерживать эти уровни независимыми один от другого, насколько это возможно, чтобы изменение в одной части проекта минимально отражалось на других частях. Если код одного уровня тесно интегрирован в код другого уровня, то трудно будет достичь этой цели.

	Реализация
	Приведем пример простого класса, который предоставляет интерфейс для процедурного кода
	*/

class ProductFacade {
	private $products = array();

	function __construct($file) {
		$this->file = $file;
		$this->compile();
	}

	private function compile() {
		$lines = getProductFileLines($this->file);
		foreach($lines as $line) {
			$id = getIDFromLine($line);
			$name = getNameFromLine($line);
			$this->products[$id] = getProductObjectFromID($id, $name);
		}
	}

	function getProducts() {
		return $this->products;
	}

	function getProduct($id) {
		if(isset($this->products[$id])) {
			return $this->products[$id];
		}
		return null;
	}
}
	//С точки зрения клиентского кода теперь доступ к объектам Product из текстового файла намного упрощен.

	$facade = new ProductFacade('test.txt');
	$facade->getProduct(234);

	/*
	Выводы
	В основе шаблона Facade на самом деле лежит очень простая идея. Это всего лишь вопрос создания одной точки входа для уровня или подсистемы в целом. В результате мы получаем ряд преимуществ, поскольку отдельные части проекта отделяются одна от другой. Программистам клиентского кода полезно и удобно иметь доступ к простым методам, которые выполняют понятные и очевидные вещи. Это позволяет сократить количество ошибок, сосредоточив обращение к подсистеме в одном месте, так что изменения в этой подсистеме вызовут сбой в предсказуемом месте. Классы Facade также минимизируют ошибки в комплексных подсистемах, где клиентский код, в противном случае, мог бы некорректно использовать внутренние функции.
	Несмотря на простоту шаблона Facade, очень легко забыть воспользоваться им, особенно если вы знакомы с подсистемой, с которой работаете. Но, конечно, тут необходимо найти нужный баланс. С одной стороны, преимущества создания простых интерфейсов для сложных систем очевидны. С другой стороны, можно необдуманно
	разделить системы, а затем разделить разделения. Если вы осуществляете значительные упрощения для пользы клиентского кода и/или экранируете его от систем, которые могут изменяться, то, вероятно, есть основания для реализации шаблона Facade.
*/