<?php

	/*

	Управление группами объектов может быть довольно сложной задачей, особенно если эти объекты также содержат собственные объекты. Это очень распространенная проблема в кодировании. Представьте счет-фактуру, в строках которой указаны дополнительные продукты или услуги, или список дел, которые нужно выполнить, элементы которого сами содержат несколько подзадач. При управлении контентом мы можем оперировать деревьями подразделов, страниц, статей и медийных компонентов. Управление этими структурами извне может быстро превратиться в очень сложную задачу. 
	Вернемся к сценарию, описанному в предыдущей главе. Напомним, что мы разрабатываем веб-систему на основе игры "цивилизация". Игрок может передвигать элементы по сотням клеток на игровом поле, которые составляют карту. При этом отдельные объекты можно  группировать, чтобы перемещаться, сражаться и защищаться так, как будто это единый элемент. Давайте определим пару типов боевых единиц (юнитов).

	*/

	abstract class Unit {
		abstract function bomЬardStrength();
	}

	class Archer extends Unit {
		function bomЬardStrength() {
			return 4;
		}

	class LaserCannonUnit extends Unit {
		function bomЬardStrength(){
			return 44;
		}
	}

	/*
	В классе Unit определен абстрактный метод bomЬardStrength(), который определяет атакующую силу элемента, обстреливающего соседнюю клетку. Мы реализуем этот метод в обоих классах - ArcherиLaserCannonUnit. Эти классы могут также содержать информацию о перемещении и возможностях защиты, но давайте пока остановимся на самом простом варианте. Мы можем определить отдельный класс для группировки юнитов следующим образом.
	*/

	class Army {
		private $units = array();

		function addUnit (Unit $unit) {
			array_push($this->units, $unit);
			//array_push — Добавляет один или несколько элементов в конец массива. Array_push() использует array, как стек и добавляет переданные значения в конец массива array. Длина array увеличивается на количество переданных значений. Имеет тот же эффект, что и выражение:
		}

		function bomЬardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}
			return $ret;
		}
	}

	/*
	У класса Army есть метод addUnit(), которому передается объект типа Unit. Объекты типа Unit сохраняются в массиве свойств с именем $units. Мы вычисляем объединенную силу нашей армии в методе bomЬardStrength(). Для этого просто выполняется итерация по объединенным объектам Unit и для каждого объекта вызывается метод bomЬardStrength(). Это идеальная модель, пока задача остается настолько простой. Но что будет, если мы добавим несколько новых требований? Предположим, армия должна быть способна объединяться с другими армиями. При этом каждая армия должна сохранять свою индивидуальность, чтобы впоследствии она могла выйти из более крупного соединения. Сегодня у храбрых вояк ArchDuke может быть общая причина с генералом Соамсом атаковать незащищенный фланг армии врага, но восстание у себя на родине может заставить его армию в любой момент поспешить домой. Поэтому мы не можем просто переместить подразделения из каждой армии в новое воинское соединение.
	Мы можем изменить класс Army так, чтобы в нем можно было оперировать, как объектами типа Arrny, так и объектами типа Unit.

	Также нам нужно изменить метод bomЬardStrength(), чтобы делать итерации по всем армиям и объектам типа Unit.
*/

	class Army {
		private $units = array();

		function addUnit (Unit $unit) {
			array_push($this->units, $unit);
		}

		function bomЬardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}

			foreach($this->armies as $army) {
				$ret += $army->bomЬardStrength();
			}

			return $ret;
		}

		function addArmy(Army $army) {
			array_push($this->armies, $army);
		}
	}

	/*
	Дополнительная сложность в данный момент не представляет особой проблемы. Но помните, что мы должны сделать нечто подобное и с другими методами, например, определяющими защитную силу defensiveStrength(),диапазон перемещения movementRange() и т.д. Наша игра обещает быть функционально богатой. Уже деловые круги вызывают транспортно-десантные самолеты, которые могут содержать до десяти юнитов, чтобы выполнить быструю переброску войск и улучшить свои позиции в некоторых районах. Очевидно, что транспортный самолет подобен армии в том, что в нем группируются объекты типа Unit. Но у него также могут быть собственные характеристики. Мы можем снова изменить класс Army, чтобы управлять транспортными самолетами (объектами TroopCarrier), но ведь может появиться необходимость и в других типах группировки объектов Unit. Очевидно, что нам нужна более гибкая модель. 
	Давайте еще раз рассмотрим модель, которую строим. Всем созданным классам нужен метод bomЬardStrength(). В сущности, клиентскому коду не нужно различать армию, юнит или транспортный самолет. Функционально они идентичны. Они должны уметь перемещаться, атаковать и защищаться. А объектам, которые содержат другие объекты, нужны методы добавления и удаления. Эти сходные черты приводят нас к неизбежному выводу. Поскольку объекты-контейнеры совместно используют интерфейс с объектами, которые они содержат, вполне естественно, что они должны принадлежать к одному семейству типов.

	Реализация
	В шаблоне Composite определяется единственная иерархия наследования, которая устанавливает два различных набора функциональных обязанностей. Мы их уже видели в нашем примере. Классы в шаблоне должны поддерживать общий набор операций, как основную обязанность. Для нашего случая - это метод bomЬardStrength(). Классы должны также поддерживать методы для добавления и удаления
	объектов.
	На рис. 10.1 показана диаграмма класса, иллюстрирующая применение шаблона Composite к данной проблеме. Как видите, все элементы нашей модели являются производными от класса Unit. Поэтому клиентский код может быть уверен, что любой объект типа Unit будет поддерживать метод bomЬardStrength(). А это значит, что с объектом Army можно обращаться точно так же, как с объектом Archer.
	Классы Army и TroopCarrier - это композиты; они предназначены для того, чтобы содержать объекты типа Unit. Классы Archer и LaserCannon - это листья, предназначенные для того, чтобы поддерживать операции с объектами типа Unit: в них не могут содержаться другие объекты типа Unit. Тут возникает вопрос "Должны ли "листья" подчиняться тому же интерфейсу, что и композиты, как показано на рис. 10.1? "На этой диаграмме показано, что в классах TroopCarrier и Arrny агрегируются другие объекты типа Unit, хотя в классах-"листьях" также нужно реализовать метод addUnit(). Вскоре я вернусь к этому вопросу, а пока определим абстрактный класс Unit.
	*/

	abstract class Unit {
		abstract function addUnit(Unit $unit);
		abstract function removeUnit(Unit $unit);
		abstract function bomЬardStrength();
	}

	/*
	Как видите, мы определили основные функции для всех объектов типа Unit. А теперь давайте посмотрим, как в объекте-композите могут быть реализованы эти абстрактные методы.
*/

	class Army extends Unit {
		
		private $units = array();

		function addUnit(Unit $unit) {
			if(in_array($unit, $this->units, true)) {
				return;
			}
			$this->units[] = $unit;
		}

		function removeUnit (Unit $unit) {
			$this->units = array_udiff($this->units, array($unit),
		}

		function($а, $b) {return ($а === $b ) ? 0:1;});

		function bombardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}
			return $ret;
		}
	}

	/*
	В методе addUnit() переданный в качестве параметра объект типа Unit сохраняется в закрытом массиве свойств $units. Перед этим проверяется, чтобы в массиве $units не было дублей объектов типа Unit. В методе removeUnit() используется аналогичная проверка, и если объект типа Unit найден, он удаляется из закрытого массива свойств $units.
	В объектах типа Army могут храниться ссылки на любые объекты типа Unit, включая другие объекты типа Army, а также листья, такие как Archer или LaserCannonUnit. Поскольку все подразделения гарантированно поддерживают метод bombardStrength(), в нашем методе Army::bomЬardStrength() просто делается итерация по всем дочерним объектам типа Unit, сохраненным в свойстве $units, и для
	каждого из них вызывается один и тот же метод. 
	Существует один проблематичный аспект шаблона Composite - это реализация функций добавления и удаления. В классическом шаблоне методы add() и remove() помещены в абстрактный суперкласс. Это гарантирует, что во всех классах шаблона совместно используется общий интерфейс. Но, как видите, это также означает, что в классах-"листьях" нужно обеспечить их реализацию.
	*/

	class UnitException extends Exception {}

	class Archer extends Unit {

		function addUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}

		function removeUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}

		function bomЬardStrength() {
			return 4;
		}
	}

	/*

	Нам не нужна возможность добавлять объект типа Unit к объекту типа Archer. Поэтому при вызове метода addUnit() или removeUnit() генерируется исключение. Нам понадобится сделать это для всех объектов-"листьев", поэтому, вероятно, мы можем улучшить проект, заменив абстрактные методы addUnit() / removeUnit() в объекте Unit стандартными реализациями, как в предыдущем примере. 
*/

	abstract class Unit {
		abstract function bomЬardStrength();

		function addUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}

		function removeUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}
	}

	class Archer extends Unit {
		function bomЬardStrength() {
			return 4 ;
		}
	}

	/*
	Такой подход позволяет избавиться от дублирования кода в классах-"листьях". Однако у него имеется серьезный недостаток - шаблон Composite во время компиляции не обязан обеспечивать реализацию методов addUnit() и removeUnit(), что в конечном итоге может стать причиной проблем. 
	Некоторые проблемы шаблона Composite мы подробнее рассмотрим в следующем разделе. А этот раздел давайте закончим тем, что  подытожим преимушества данного шаблона.

•	Гибкость. Поскольку во всех элементах шаблона Composite используется общий супертип, очень просто добавлять к проекту новые объекты-композиты или "листья", не меняя более широкий контекст программы.

• Простота. Клиентский код, использующий структуру Composite, имеет простой интерфейс. Клиентскому коду не нужно делать различие между объектом, состоящим из других объектов, и объектом-"листом" (за исключением случая добавления новых компонентов). Вызов метода Army::bomЬardStrength() может стать причиной серии делегированных внутренних вызовов, но для клиентского кода процесс и результат в точности эквивалентны тому, что связано с вызовом Archer::bomЬardStrength().

• Неявная досягаемость. В шаблоне Composite объекты организованы в древовидную структуру. В каждом композите содержатся ссылки на дочерний объект. Поэтому операция над определенной частью дерева может иметь более широкий эффект. Мы можем удалить один объект Army из его родительского объекта Army и добавить к другому. Это простое действие осуществляется над одним объектом, но в результате изменяется статус объектов Unit, на которые ссылается объект Army, а также статус их дочерних объектов.

• Явная досягаемость. В древовидной структуре можно легко выполнить обход всех ее узлов. Для получения информации нужно последовательно перебрать все ее узлы либо выполнить преобразования. Очень эффективные методы осуществления этих действий мы рассмотрим в следующей главе при изучении шаблона Visitor.

Во многих случаях реально увидеть преимушества шаблона можно только с точки
зрения клиентского кода, поэтому давайте создадим пару армий.
	*/

// Создадим армию
$main_army = new Army();

// Добавим пару боевых единиц
$main_army->addUnit(new Archer());
$main_army->addUnit(new LaserCannonUnit());

// Создадим еще одну армию
$sub_army nеw Army();

// Добавим несколько боевых единиц
$sub_army->addUnit(new Archer());
$sub_army->addUnit(new Archer());
$sub_army->addUnit(new Archer());

// Добавим вторую армию к первой
$main_army->addUnit($sub_army);

// Все вычисления выполняются за кулисами
print "Атакующая сила : {$main_army->bomЬardStrength()}\n";

/*
Мы создаем новый объект Army и добавляем несколько боевых единиц Unit. Повторяем этот процесс для второго объекта Army, который затем добавляем к первому. Когда мы вызываем метод Unit::bomЬardStrength() для первого объекта Army, вся сложность структуры, которую мы построили, оказывается полностью скрытой.


Промежуточные выводы
Если вы в чем-то похожи на меня, то, увидев фрагмент кода для класса Archer, должны были сильно задуматься. Для чего нам нужны эти лишние методы addUnit() и removeUnit() в классах-wлистьях", которые по логике вещей не должны в них поддерживаться? Ответ заключается в прозрачности типа Unit.
Если клиентский код оперирует объектом типа Unit, то ему известно, что метод addUnit() всегда присутствует. В результате выполняется принцип шаблона Composite, который заключается в том, что у элементарных классов ("листьев") такой же интерфейс, как у композитов. Это не особенно нам помогает, потому что мы по-прежнему не знаем, насколько безопасно вызывать метод addUnit() для любого объекта U nit, с которым мы можем столкнуться.
Если переместить эти методы добавления/удаления вниз, чтобы они были доступны только классам композитов, то при передаче объекта типа Unit методу возникает проблема из-за того, что по умолчанию мы не знаем, поддерживает он метод addUnit() или нет. Тем не менее оставлять методы-заглушки в классах-"листьях" мне кажется неправильным. Пользы от этого никакой, а проект усложняется, поскольку
интерфейс дает ложные сведения о собственной функциональности.
Мы можем легко разбить классы-композиты на подтипы CompositeUnit. Прежде всего, мы исключим функции добавления/удаления боевых единиц из класса Unit.
*/

	abstract class Unit {
		function getComposite(){
			return null;
		}
		abstract function bomЬardStrength();
	}

	/*
Обратите внимание на новый метод getComposite(). Мы вернемся к нему через некоторое время. А теперь нам нужен новый абстрактный класс, который будет поддерживать методы addUnit() и removeUnit(). Мы можем обеспечить даже его стандартные реализации.
	*/

	abstract class CompositeUnit extends Unit {
		private $units = array();

		function getComposite() {
			return $this;
		}

		protected function units() {
			return $this->units;
		}

		function removeUnit (Unit $unit) {
			$this->units = array_udiff($this->units, array($unit),
			function($а, $b) {return ($а === $b) ?O : l; });
		}

		function addUnit (Unit $unit) {
			if (in_array($unit, $this->units, true)) {
				return;
			}
			$this->units[] = $unit;
		}
	}

	/*

	Класс CompositeUnit объявлен абстрактным, несмотря на то что в нем не объявлено никаких абстрактных методов. Однако он расширяет класс Unit и в нем не реализован абстрактный метод bombardStrength(). Класс Army (и любые другие классы-композиты) теперь может расширять класс CompositeUnit.
*/

