<?php

	/*

	Управление группами объектов может быть довольно сложной задачей, особенно если эти объекты также содержат собственные объекты. Это очень распространенная проблема в кодировании. Представьте счет-фактуру, в строках которой указаны дополнительные продукты или услуги, или список дел, которые нужно выполнить, элементы которого сами содержат несколько подзадач. При управлении контентом мы можем оперировать деревьями подразделов, страниц, статей и медийных компонентов. Управление этими структурами извне может быстро превратиться в очень сложную задачу. 
	Вернемся к сценарию, описанному в предыдущей главе. Напомним, что мы разрабатываем веб-систему на основе игры "цивилизация". Игрок может передвигать элементы по сотням клеток на игровом поле, которые составляют карту. При этом отдельные объекты можно  группировать, чтобы перемещаться, сражаться и защищаться так, как будто это единый элемент. Давайте определим пару типов боевых единиц (юнитов).

	*/

	abstract class Unit {
		abstract function bomЬardStrength();
	}

	class Archer extends Unit {
		function bomЬardStrength() {
			return 4;
		}

	class LaserCannonUnit extends Unit {
		function bomЬardStrength(){
			return 44;
		}
	}

	/*
	В классе Unit определен абстрактный метод bomЬardStrength(), который определяет атакующую силу элемента, обстреливающего соседнюю клетку. Мы реализуем этот метод в обоих классах - ArcherиLaserCannonUnit. Эти классы могут также содержать информацию о перемещении и возможностях защиты, но давайте пока остановимся на самом простом варианте. Мы можем определить отдельный класс для группировки юнитов следующим образом.
	*/

	class Army {
		private $units = array();

		function addUnit (Unit $unit) {
			array_push($this->units, $unit);
			//array_push — Добавляет один или несколько элементов в конец массива. Array_push() использует array, как стек и добавляет переданные значения в конец массива array. Длина array увеличивается на количество переданных значений. Имеет тот же эффект, что и выражение:
		}

		function bomЬardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}
			return $ret;
		}
	}

	/*
	У класса Army есть метод addUnit(), которому передается объект типа Unit. Объекты типа Unit сохраняются в массиве свойств с именем $units. Мы вычисляем объединенную силу нашей армии в методе bomЬardStrength(). Для этого просто выполняется итерация по объединенным объектам Unit и для каждого объекта вызывается метод bomЬardStrength(). Это идеальная модель, пока задача остается настолько простой. Но что будет, если мы добавим несколько новых требований? Предположим, армия должна быть способна объединяться с другими армиями. При этом каждая армия должна сохранять свою индивидуальность, чтобы впоследствии она могла выйти из более крупного соединения. Сегодня у храбрых вояк ArchDuke может быть общая причина с генералом Соамсом атаковать незащищенный фланг армии врага, но восстание у себя на родине может заставить его армию в любой момент поспешить домой. Поэтому мы не можем просто переместить подразделения из каждой армии в новое воинское соединение.
	Мы можем изменить класс Army так, чтобы в нем можно было оперировать, как объектами типа Arrny, так и объектами типа Unit.

	Также нам нужно изменить метод bomЬardStrength(), чтобы делать итерации по всем армиям и объектам типа Unit.
*/

	class Army {
		private $units = array();

		function addUnit (Unit $unit) {
			array_push($this->units, $unit);
		}

		function bomЬardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}

			foreach($this->armies as $army) {
				$ret += $army->bomЬardStrength();
			}

			return $ret;
		}

		function addArmy(Army $army) {
			array_push($this->armies, $army);
		}
	}

	/*
	Дополнительная сложность в данный момент не представляет особой проблемы. Но помните, что мы должны сделать нечто подобное и с другими методами, например, определяющими защитную силу defensiveStrength(),диапазон перемещения movementRange() и т.д. Наша игра обещает быть функционально богатой. Уже деловые круги вызывают транспортно-десантные самолеты, которые могут содержать до десяти юнитов, чтобы выполнить быструю переброску войск и улучшить свои позиции в некоторых районах. Очевидно, что транспортный самолет подобен армии в том, что в нем группируются объекты типа Unit. Но у него также могут быть собственные характеристики. Мы можем снова изменить класс Army, чтобы управлять транспортными самолетами (объектами TroopCarrier), но ведь может появиться необходимость и в других типах группировки объектов Unit. Очевидно, что нам нужна более гибкая модель. 
	Давайте еще раз рассмотрим модель, которую строим. Всем созданным классам нужен метод bomЬardStrength(). В сущности, клиентскому коду не нужно различать армию, юнит или транспортный самолет. Функционально они идентичны. Они должны уметь перемещаться, атаковать и защищаться. А объектам, которые содержат другие объекты, нужны методы добавления и удаления. Эти сходные черты приводят нас к неизбежному выводу. Поскольку объекты-контейнеры совместно используют интерфейс с объектами, которые они содержат, вполне естественно, что они должны принадлежать к одному семейству типов.

	Реализация
	В шаблоне Composite определяется единственная иерархия наследования, которая устанавливает два различных набора функциональных обязанностей. Мы их уже видели в нашем примере. Классы в шаблоне должны поддерживать общий набор операций, как основную обязанность. Для нашего случая - это метод bomЬardStrength(). Классы должны также поддерживать методы для добавления и удаления
	объектов.
	На рис. 10.1 показана диаграмма класса, иллюстрирующая применение шаблона Composite к данной проблеме. Как видите, все элементы нашей модели являются производными от класса Unit. Поэтому клиентский код может быть уверен, что любой объект типа Unit будет поддерживать метод bomЬardStrength(). А это значит, что с объектом Army можно обращаться точно так же, как с объектом Archer.
	Классы Army и TroopCarrier - это композиты; они предназначены для того, чтобы содержать объекты типа Unit. Классы Archer и LaserCannon - это листья, предназначенные для того, чтобы поддерживать операции с объектами типа Unit: в них не могут содержаться другие объекты типа Unit. Тут возникает вопрос "Должны ли "листья" подчиняться тому же интерфейсу, что и композиты, как показано на рис. 10.1? "На этой диаграмме показано, что в классах TroopCarrier и Arrny агрегируются другие объекты типа Unit, хотя в классах-"листьях" также нужно реализовать метод addUnit(). Вскоре я вернусь к этому вопросу, а пока определим абстрактный класс Unit.
	*/

	abstract class Unit {
		abstract function addUnit(Unit $unit);
		abstract function removeUnit(Unit $unit);
		abstract function bomЬardStrength();
	}

	/*
	Как видите, мы определили основные функции для всех объектов типа Unit. А теперь давайте посмотрим, как в объекте-композите могут быть реализованы эти абстрактные методы.
*/

	class Army extends Unit {
		
		private $units = array();

		function addUnit(Unit $unit) {
			if(in_array($unit, $this->units, true)) {
				return;
			}
			$this->units[] = $unit;
		}

		function removeUnit (Unit $unit) {
			$this->units = array_udiff($this->units, array($unit),
		}

		function($а, $b) {return ($а === $b ) ? 0:1;});

		function bombardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}
			return $ret;
		}
	}

	/*
	В методе addUnit() переданный в качестве параметра объект типа Unit сохраняется в закрытом массиве свойств $units. Перед этим проверяется. чтобы в массиве $units не было дублей объектов типа Unit. В методе removeUnit() используется аналогичная проверка, и если объект типа Unit найден, он удаляется из закрытого массива свойств $units.
	*/

	//