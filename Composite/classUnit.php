<?php

	/*

	Управление группами объектов может быть довольно сложной задачей, особенно если эти объекты также содержат собственные объекты. Это очень распространенная проблема в кодировании. Представьте счет-фактуру, в строках которой указаны дополнительные продукты или услуги, или список дел, которые нужно выполнить, элементы которого сами содержат несколько подзадач. При управлении контентом мы можем оперировать деревьями подразделов, страниц, статей и медийных компонентов. Управление этими структурами извне может быстро превратиться в очень сложную задачу. 
	Вернемся к сценарию, описанному в предыдущей главе. Напомним, что мы разрабатываем веб-систему на основе игры "цивилизация". Игрок может передвигать элементы по сотням клеток на игровом поле, которые составляют карту. При этом отдельные объекты можно  группировать, чтобы перемещаться, сражаться и защищаться так, как будто это единый элемент. Давайте определим пару типов боевых единиц (юнитов).

	*/

	abstract class Unit {
		abstract function bomЬardStrength();
	}

	class Archer extends Unit {
		function bomЬardStrength() {
			return 4;
		}

	class LaserCannonUnit extends Unit {
		function bomЬardStrength(){
			return 44;
		}
	}

	/*
	В классе Unit определен абстрактный метод bomЬardStrength(), который определяет атакующую силу элемента, обстреливающего соседнюю клетку. Мы реализуем этот метод в обоих классах - ArcherиLaserCannonUnit. Эти классы могут также содержать информацию о перемещении и возможностях защиты, но давайте пока остановимся на самом простом варианте. Мы можем определить отдельный класс для группировки юнитов следующим образом.
	*/

	class Army {
		private $units = array();

		function addUnit (Unit $unit) {
			array_push($this->units, $unit);
			//array_push — Добавляет один или несколько элементов в конец массива. Array_push() использует array, как стек и добавляет переданные значения в конец массива array. Длина array увеличивается на количество переданных значений. Имеет тот же эффект, что и выражение:
		}

		function bomЬardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}
			return $ret;
		}
	}

	/*
	У класса Army есть метод addUnit(), которому передается объект типа Unit. Объекты типа Unit сохраняются в массиве свойств с именем $units. Мы вычисляем объединенную силу нашей армии в методе bomЬardStrength(). Для этого просто выполняется итерация по объединенным объектам Unit и для каждого объекта вызывается метод bomЬardStrength(). Это идеальная модель, пока задача остается настолько простой. Но что будет, если мы добавим несколько новых требований? Предположим, армия должна быть способна объединяться с другими армиями. При этом каждая армия должна сохранять свою индивидуальность, чтобы впоследствии она могла выйти из более крупного соединения. Сегодня у храбрых вояк ArchDuke может быть общая причина с генералом Соамсом атаковать незащищенный фланг армии врага, но восстание у себя на родине может заставить его армию в любой момент поспешить домой. Поэтому мы не можем просто переместить подразделения из каждой армии в новое воинское соединение.
	Мы можем изменить класс Army так, чтобы в нем можно было оперировать, как объектами типа Arrny, так и объектами типа Unit.

	Также нам нужно изменить метод bomЬardStrength(), чтобы делать итерации по всем армиям и объектам типа Unit.
*/

	class Army {
		private $units = array();

		function addUnit (Unit $unit) {
			array_push($this->units, $unit);
		}

		function bomЬardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}

			foreach($this->armies as $army) {
				$ret += $army->bomЬardStrength();
			}

			return $ret;
		}

		function addArmy(Army $army) {
			array_push($this->armies, $army);
		}
	}

	/*
	Дополнительная сложность в данный момент не представляет особой проблемы. Но помните, что мы должны сделать нечто подобное и с другими методами, например, определяющими защитную силу defensiveStrength(),диапазон перемещения movementRange() и т.д. Наша игра обещает быть функционально богатой. Уже деловые круги вызывают транспортно-десантные самолеты, которые могут содержать до десяти юнитов, чтобы выполнить быструю переброску войск и улучшить свои позиции в некоторых районах. Очевидно, что транспортный самолет подобен армии в том, что в нем группируются объекты типа Unit. Но у него также могут быть собственные характеристики. Мы можем снова изменить класс Army, чтобы управлять транспортными самолетами (объектами TroopCarrier), но ведь может появиться необходимость и в других типах группировки объектов Unit. Очевидно, что нам нужна более гибкая модель. 
	Давайте еще раз рассмотрим модель, которую строим. Всем созданным классам нужен метод bomЬardStrength(). В сущности, клиентскому коду не нужно различать армию, юнит или транспортный самолет. Функционально они идентичны. Они должны уметь перемещаться, атаковать и защищаться. А объектам, которые содержат другие объекты, нужны методы добавления и удаления. Эти сходные черты приводят нас к неизбежному выводу. Поскольку объекты-контейнеры совместно используют интерфейс с объектами, которые они содержат, вполне естественно, что они должны принадлежать к одному семейству типов.

	Реализация
	В шаблоне Composite определяется единственная иерархия наследования, которая устанавливает два различных набора функциональных обязанностей. Мы их уже видели в нашем примере. Классы в шаблоне должны поддерживать общий набор операций, как основную обязанность. Для нашего случая - это метод bomЬardStrength(). Классы должны также поддерживать методы для добавления и удаления
	объектов.
	На рис. 10.1 показана диаграмма класса, иллюстрирующая применение шаблона Composite к данной проблеме. Как видите, все элементы нашей модели являются производными от класса Unit. Поэтому клиентский код может быть уверен, что любой объект типа Unit будет поддерживать метод bomЬardStrength(). А это значит, что с объектом Army можно обращаться точно так же, как с объектом Archer.
	Классы Army и TroopCarrier - это композиты; они предназначены для того, чтобы содержать объекты типа Unit. Классы Archer и LaserCannon - это листья, предназначенные для того, чтобы поддерживать операции с объектами типа Unit: в них не могут содержаться другие объекты типа Unit. Тут возникает вопрос "Должны ли "листья" подчиняться тому же интерфейсу, что и композиты, как показано на рис. 10.1? "На этой диаграмме показано, что в классах TroopCarrier и Arrny агрегируются другие объекты типа Unit, хотя в классах-"листьях" также нужно реализовать метод addUnit(). Вскоре я вернусь к этому вопросу, а пока определим абстрактный класс Unit.
	*/

	abstract class Unit {
		abstract function addUnit(Unit $unit);
		abstract function removeUnit(Unit $unit);
		abstract function bomЬardStrength();
	}

	/*
	Как видите, мы определили основные функции для всех объектов типа Unit. А теперь давайте посмотрим, как в объекте-композите могут быть реализованы эти абстрактные методы.
*/

	class Army extends Unit {
		
		private $units = array();

		function addUnit(Unit $unit) {
			if(in_array($unit, $this->units, true)) {
				return;
			}
			$this->units[] = $unit;
		}

		function removeUnit (Unit $unit) {
			$this->units = array_udiff($this->units, array($unit),
			//array_udiff — Вычисляет расхождение массивов, используя для сравнения callback-функцию
			function($а, $b) {return ($а === $b ) ? 0:1;});
		}

		function bombardStrength() {
			$ret = О;
			foreach ($this->units as $unit) {
				$ret += $unit->bomЬardStrength();
			}
			return $ret;
		}
	}

	/*
	В методе addUnit() переданный в качестве параметра объект типа Unit сохраняется в закрытом массиве свойств $units. Перед этим проверяется, чтобы в массиве $units не было дублей объектов типа Unit. В методе removeUnit() используется аналогичная проверка, и если объект типа Unit найден, он удаляется из закрытого массива свойств $units.
	В объектах типа Army могут храниться ссылки на любые объекты типа Unit, включая другие объекты типа Army, а также листья, такие как Archer или LaserCannonUnit. Поскольку все подразделения гарантированно поддерживают метод bombardStrength(), в нашем методе Army::bomЬardStrength() просто делается итерация по всем дочерним объектам типа Unit, сохраненным в свойстве $units, и для
	каждого из них вызывается один и тот же метод. 
	Существует один проблематичный аспект шаблона Composite - это реализация функций добавления и удаления. В классическом шаблоне методы add() и remove() помещены в абстрактный суперкласс. Это гарантирует, что во всех классах шаблона совместно используется общий интерфейс. Но, как видите, это также означает, что в классах-"листьях" нужно обеспечить их реализацию.
	*/

	class UnitException extends Exception {}

	class Archer extends Unit {

		function addUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}

		function removeUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}

		function bombardStrength() {
			return 4;
		}
	}

	/*

	Нам не нужна возможность добавлять объект типа Unit к объекту типа Archer. Поэтому при вызове метода addUnit() или removeUnit() генерируется исключение. Нам понадобится сделать это для всех объектов-"листьев", поэтому, вероятно, мы можем улучшить проект, заменив абстрактные методы addUnit() / removeUnit() в объекте Unit стандартными реализациями, как в предыдущем примере. 
*/

	abstract class Unit {
		abstract function bomЬardStrength();

		function addUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}

		function removeUnit(Unit $unit) {
			throw new UnitException(get_class($this) . " относится к 'листьям'");
		}
	}

	class Archer extends Unit {
		function bomЬardStrength() {
			return 4 ;
		}
	}

	/*
	Такой подход позволяет избавиться от дублирования кода в классах-"листьях". Однако у него имеется серьезный недостаток - шаблон Composite во время компиляции не обязан обеспечивать реализацию методов addUnit() и removeUnit(), что в конечном итоге может стать причиной проблем. 
	Некоторые проблемы шаблона Composite мы подробнее рассмотрим в следующем разделе. А этот раздел давайте закончим тем, что  подытожим преимушества данного шаблона.

•	Гибкость. Поскольку во всех элементах шаблона Composite используется общий супертип, очень просто добавлять к проекту новые объекты-композиты или "листья", не меняя более широкий контекст программы.

• Простота. Клиентский код, использующий структуру Composite, имеет простой интерфейс. Клиентскому коду не нужно делать различие между объектом, состоящим из других объектов, и объектом-"листом" (за исключением случая добавления новых компонентов). Вызов метода Army::bomЬardStrength() может стать причиной серии делегированных внутренних вызовов, но для клиентского кода процесс и результат в точности эквивалентны тому, что связано с вызовом Archer::bomЬardStrength().

• Неявная досягаемость. В шаблоне Composite объекты организованы в древовидную структуру. В каждом композите содержатся ссылки на дочерний объект. Поэтому операция над определенной частью дерева может иметь более широкий эффект. Мы можем удалить один объект Army из его родительского объекта Army и добавить к другому. Это простое действие осуществляется над одним объектом, но в результате изменяется статус объектов Unit, на которые ссылается объект Army, а также статус их дочерних объектов.

• Явная досягаемость. В древовидной структуре можно легко выполнить обход всех ее узлов. Для получения информации нужно последовательно перебрать все ее узлы либо выполнить преобразования. Очень эффективные методы осуществления этих действий мы рассмотрим в следующей главе при изучении шаблона Visitor.

Во многих случаях реально увидеть преимушества шаблона можно только с точки
зрения клиентского кода, поэтому давайте создадим пару армий.
	*/

// Создадим армию
$main_army = new Army();

// Добавим пару боевых единиц
$main_army->addUnit(new Archer());
$main_army->addUnit(new LaserCannonUnit());

// Создадим еще одну армию
$sub_army new Army();

// Добавим несколько боевых единиц
$sub_army->addUnit(new Archer());
$sub_army->addUnit(new Archer());
$sub_army->addUnit(new Archer());

// Добавим вторую армию к первой
$main_army->addUnit($sub_army);

// Все вычисления выполняются за кулисами
print "Атакующая сила : {$main_army->bomЬardStrength()}\n";

/*
Мы создаем новый объект Army и добавляем несколько боевых единиц Unit. Повторяем этот процесс для второго объекта Army, который затем добавляем к первому. Когда мы вызываем метод Unit::bomЬardStrength() для первого объекта Army, вся сложность структуры, которую мы построили, оказывается полностью скрытой.


Промежуточные выводы
Если вы в чем-то похожи на меня, то, увидев фрагмент кода для класса Archer, должны были сильно задуматься. Для чего нам нужны эти лишние методы addUnit() и removeUnit() в классах-"листьях", которые по логике вещей не должны в них поддерживаться? Ответ заключается в прозрачности типа Unit.
Если клиентский код оперирует объектом типа Unit, то ему известно, что метод addUnit() всегда присутствует. В результате выполняется принцип шаблона Composite, который заключается в том, что у элементарных классов ("листьев") такой же интерфейс, как у композитов. Это не особенно нам помогает, потому что мы по-прежнему не знаем, насколько безопасно вызывать метод addUnit() для любого объекта U nit, с которым мы можем столкнуться.
Если переместить эти методы добавления/удаления вниз, чтобы они были доступны только классам композитов, то при передаче объекта типа Unit методу возникает проблема из-за того, что по умолчанию мы не знаем, поддерживает он метод addUnit() или нет. Тем не менее оставлять методы-заглушки в классах-"листьях" мне кажется неправильным. Пользы от этого никакой, а проект усложняется, поскольку
интерфейс дает ложные сведения о собственной функциональности.
Мы можем легко разбить классы-композиты на подтипы CompositeUnit. Прежде всего, мы исключим функции добавления/удаления боевых единиц из класса Unit.
*/

	abstract class Unit {
		function getComposite(){
			return null;
		}
		abstract function bomЬardStrength();
	}

	/*
Обратите внимание на новый метод getComposite(). Мы вернемся к нему через некоторое время. А теперь нам нужен новый абстрактный класс, который будет поддерживать методы addUnit() и removeUnit(). Мы можем обеспечить даже его стандартные реализации.
	*/

	abstract class CompositeUnit extends Unit {
		private $units = array();

		function getComposite() {
			return $this;
		}

		protected function units() {
			return $this->units;
		}

		function removeUnit (Unit $unit) {
			$this->units = array_udiff($this->units, array($unit),
			function($а, $b) {return ($а === $b) ?O : l; });
		}

		function addUnit (Unit $unit) {
			if (in_array($unit, $this->units, true)) {
				return;
			}
			$this->units[] = $unit;
		}
	}

	/*

	Класс CompositeUnit объявлен абстрактным, несмотря на то что в нем не объявлено никаких абстрактных методов. Однако он расширяет класс Unit и в нем не реализован абстрактный метод bombardStrength(). Класс Army (и любые другие классы-композиты) теперь может расширять класс CompositeUnit.

	Теперь у нас нет бесполезной реализации методов добавления/удаления боевых единиц в классах-"листьях", но в клиентском коде перед вызовом метода addUnit() нужно по-прежнему проверить тип объекта (унаследован ли он от класса CompositeUnit). Вот тут-то и вступает в свои права метод getComposite(). По умолчанию этот метод возвращает нулевое значение. Только в классе CompositeUnit он возвращает ссылку на объект типа CompositeUnit. Поэтому если вызов этого метода возвращает объект, то мы должны иметь возможность вызвать для него метод addUnit(). Вот как это можно использовать в клиентском коде.
*/

	class UnitScript {
		private $comp;

		static function joinExisting(Unit $newUnit, Unit $occupyingUnit) {
			if(!is null($comp = $occupyingUnit->getComposite())) {
				$comp->addUnit($newUnit);
			else {
				$comp = new Army();
				$comp->addUnit($occupyingUnit);
				$comp->addUnit($newUnit);
			}

			return $comp;
		}
	}

	/*
	Методу joinExisting() передаются два объекта типа Unit. Первый - это объект, вновь прибывший на клетку, а второй - объект, который занимал клетку до этого. Если второй объект типа Unit принадлежит к клaccy CompositeUnit, то первый объект попытается присоединиться к нему. Если нет, то будет создан новый объект типа Аrmу, включающий оба объекта типа Unit. А с самого начала у нас нет способа узнать, содержит ли арrумент $occupyingUnit объект клacca CompositeUnit. Но вызов метода getComposite() позволит решить проблему. Если метод getComposite() возвращает объект, то мы можем непосредственно добавить к нему новый объект типа Unit. В противном случае мы создадим новый объект типа Army и добавим к нему оба объекта.

	Мы можем еще более упростить эту модель, сделав так, чтобы метод Unit::getComposite() вернул объект типа Army, содержащий текущий объект типа Unit. Либо можем вернуться к предыдущей модели (в которой не было структурного разделения между объектами-композитами и "листьями"), где метод Unit::addUnit() делает то же самое: создает объект типа Army и добавляет к нему оба Объекта типа Unit. Это ясно и понятно, когда предполагается, что вы знаете заранее тип композита, который хотите использовать для объединения объектов типа Unit. Предположения, которые вы сделаете при проектировании таких методов, как getComposite() и addUnit(), будут определяться логикой вашего приложения.

	Эти перекосы говорят о недостатках шаблона Composite. Простота достигается за счет гарантии того, что все Классы происходят из общего базового клacca. Но за простоту иногда приходится платить безопасностью использования типа. Чем сложнее становится модель, тем больше вероятность, что вам придется вручную делать проверку типов. Предположим, у нас есть объект типа Cavalry (кавалерия). Если по правилам нашей игры нельзя помещать лошадь на бронетранспортер, то мы не сможем автоматически сделать это с помощью шаблона Composite.
	*/

	class TroopCarrier extends CompositeUnit {
		function addUnit(Unit $unit) {
			if($unit instanceof Cavalry) {
				//Оператор instanceof используется для определения того, является ли текущий объект экземпляром указанного класса
				throw new UnitException ("Нельзя помещать лошадь на бронетранспортер");
			}
			super::addUnit($unit);
		}

		function bombardStrength() {
			return 0;
		}
	}

	/*

	Здесь мы обязаны использовать оператор instanceof, чтобы протестировать тип объекта, переданного методу addUnit(). Случаев подобного рода существует слишком много, поэтому недостатки шаблона начинают перевешивать его преимущества. Шаблон Composite наиболее эффективен, когда большинство компонентов являются взаимозаменяемыми.

	Еще один вопрос, о котором нужно помнить, - это стоимость некоторых операций шаблона Composite. Метод Army::bomЬardStrength() типичен в том, что запускает серию вызовов одного и того же метода вниз по дереву. Для большого дерева с множеством вложенных армий единственный вызов может стать причиной лавины внутренних вызовов. Метод bomЬardStrength() сам по себе не является слишком "дорогим", но что произойдет, если некоторые "листья" должны выполнять сложные вычисления, чтобы получить возвращаемые значения? Один из способов решения этой проблемы - сохранить результат вызова подобного метода в родительском объекте, чтобы последующие вызовы не обходились так дорого. Но вы должны быть внимательны и гарантировать, чтобы сохраненное значение не устарело. Необходимо разработать стратегии удаления всех сохраненных значений, когда на дереве выполняются какие-либо операции. Для этого, возможно, понадобится дать дочерним объектам ссылки на их родительские объекты.

	И наконец - замечание по поводу сохраняемости. Шаблон Composite довольно изящен, но не слишком пригоден для сохранения в реляционной базе данных. Причина в том. что по умолчанию вы обращаетесь ко всей структуре только с помощью серии ссылок. Поэтому, чтобы естественным образом построить структуру Composite на основе базы данных, вам придется делать множество "дорогостоящих" запросов. Можно решить эту проблему, присвоив идентификатор ID всему дереву, чтобы все компоненты можно было извлекать из базы данных за один раз. Но, получив все объекты, нам по-прежнему нужно воссоздавать ссылки "родительский объект-дочерний объект", которые, в свою очередь, должны сохраняться в базе данных. Это нетрудно, но достаточно неприятно.

	Как уже говорилось, шаблоны типа Composite трудно сохранять в реляционной базе данных, но зато они отлично подходят для сохранения в формате ХМL. Это объясняется тем, что ХМL-элементы, как правило, сами состоят из деревьев вложенных элементов.


	Выводы о шаблоне Composite

	Итак, шаблон Composite полезен, когда нужно обращаться с набором объектов так же, как с отдельным объектом, либо потому, что набор по своей сути такой же, как компонент (например, армии и лучники), либо потому, что контекст придает набору такие же характеристики, как компоненту (например, строки в счете-фактуре). Шаблоны Composite организованы в виде деревьев, поэтому операция на целом дереве может затронуть его части, и данные частей очевидным образом доступны для всего целого. Шаблон Composite делает такие операции и запросы прозрачными для клиентского кода. К тому же деревья легко обходить (как мы увидим в следующей главе). К структурам типа Composite легко добавлять новые типы компонентов. 

	Недостаток шаблона Composite в том, что он зависит от сходства своих частей. Как только мы введем сложные правила в отношении того, какие объекты-композиты какие наборы компонентов могут содержать, управлять кодом станет трудно. Шаблоны Composite не слишком пригодны для сохранения в реляционной базе данных, но зато они отлично приспособлены для сохранения в ХМL-формате.
	*/

