<?php

/*Если говорить кратко. то класс - это шаблон кода. который используется для создания объектов. Класс объявляется с помощью ключевого слова class и произвольного имени класса. В именах классов может использоваться любое сочетание букв и цифр. но они не должны начинаться с цифры. Код. связанный с классом, должен быть заключен в фиrурные скобки. Давайте объединим эти элементы , чтобы построить класс.
*/

class ShopProduct {
	// Тело класса
}

/*
Первые несколько объектов
Если класс -это шаблон для создания объектов, следовательно. объект - это данные, которые структурируются в соответствии с шаблоном, определенным в классе. При этом говорят. что объект - это экземпляр класса. Его тип определяется классом. Мы будем использовать класс ShopProduct как форму для создания объектов типа ShopProduct. Для этого нам нужен оператор new. Он используется совместно с именем класса следующим образом.
*/

$product1 = new ShopProduct();
$product2 = new ShopProduct();

/*
После оператора new указывается имя класса в качестве его единственного операнда. В результате он создает экземпляр этого класса; в нашем примере создается объект типа ShopProduct.
Итак, мы использовали класс ShopProduct как шаблон для создания двух объектов типа ShopProduct. Хотя функционально они идентичны (т.е. пусты), $productl и $product2 - это два разных объекта одного типа, созданные с помощью одного класса.
Если вам все еще не понятно, давайте приведем такую аналогию. Представьте, что класс - это форма для отливки, с помощью которой изготавливают пластмассовые утки. Объекты - это и есть утки. тип создаваемых объектов определяется формой отливки. Утки выглядят одинаковыми во всех отношениях, но все-таки это разные предметы . Другими словами, это разные экземпляры одного и того же типа. У уток могут быть даже разные серийные номера, подтверждающие их индивидуальность. Каждому объекту, создаваемому в РНР-сценарии, также присваивается уникальный идентификатор (он уникален на время жизни объекта, т.е. в РНР повторно используются идентификаторы, даже в пределах одного и того же процесса (т.е. запуска
сценария)). Это можно продемонстрировать, выведя на печать объекты $product1 и $product2.
*/

var_dump($product1);
var_dump($product2);

echo "<br><br>";
/*
После выполнения этих функций будут выведены следующие данные.
object(ShopProduct)#1 (0) { } 
object(ShopProduct)#2 (0) { }

На заметку. В РНР 4 и РНР 5 (до версии 5.1 включительно) можно выводить объекты на печать непосредственно. В результате объект будет преобразован в строку, содержащую идентификатор объекта. Начиная с версии РНР 5.2 и выше такая возможность больше не поддерживается, и любая попытка рассматривать объект как строку приведет к ошибке, если только в классе этого объекта не будет определен метод toString()
Методы будут рассмотрены далее в этой главе, а метод __toString() - в главе 4, "Расширенные средства".

Передав наши объекты функции var_dump(), мы можем узнать о них полезную информацию, включая внутренний идентификатор каждого объекта, указанный после символа ' # '. Чтобы сделать эти объекты более интересными, мы должны немного изменить определение класса ShopProduct, добавив в него специальные поля данных, называемые свойствами (properties).
*/


/*
Определение свойств в классе
В классах можно определять специальные переменные, которые называются свойствами. Свойство, которое называется также переменной-членом (member variaЬle), содержит данные, которые могут изменяться от одного объекта к другому. В случае объектов ShopProduct нам нужно иметь возможность изменять, например, поля, содержащие название товара и его цену. 
Определение свойства в классе похоже на определение обычной переменной, за исключением того, что в операторе объявления перед именем свойства нужно поместить одно из ключевых слов, характеризующих область его видимости: public, protected или private.

На заметку. Область видимости (scope) определяет контекст функции или класса, в котором можно пользоваться данной переменной 
(или методом, о чем мы поговорим далее в этой главе). Так, переменная, определенная внутри тела функции, имеет локальную область видимости, а переменная, определенная за пределами функции, - глобальную область видимости. Как правило, нельзя получить доступ к данным, находящимся в локализованных областях видимости по отношению к текущей области. Поэтому, определив переменную внутри функции, вы впоследствии не сможете получить к ней доступ извне этой функции. Объекты в этом смысле более "проницаемы", и к некоторым объектным переменным можно иногда получать доступ из другого контекста. К каким переменным можно получать доступ и из какого контекста, и определяют ключевые слова public, protected и private, как мы вскоре увидим.

К этим ключевым словам и вопросу видимости мы вернемся несколько позже в этой главе. А сейчас давайте определим некоторые свойства с помощью ключевого
слова puЬlic.
*/

class ShopProduct2 {
	public $title             = "Стандартный товар";
	public $producerMainName  = "Фамилия автора";
	public $producerFirstName = "Имя автора";
	public $price             = 0;
}

/*
Как видите, мы определили четыре свойства, присвоив каждому из них стандартное значение. Теперь любым объектам, экземпляры которых мы будем создавать с помощью класса ShopProduct, будут присвоены стандартные данные. А ключевое слово public, присутствующее в объявлении каждого свойства, обеспечит доступ к этому свойству извне контекста объекта.

На заметку. Ключевые слова public, protected и private, определяющие область видимости свойств, появились в РНР 5. В версии РНР 4 приведенные выше примеры работать не будут. В РНР 4 все свойства должны быть объявлены с помощью ключевого слова var, что, по сути, идентично использованию ключевого слова public. Исходя из принципа обратной совместимости, в РНР 5 допускается использование для свойств ключевого слова var вместо public.

К переменным свойств можно обращаться с помощью символов '->', указав имя объектной переменной и имя свойства.
*/

$product1 = new ShopProduct2();
print $product1->title;
echo "<br><br>";

/*
В результате будет выведено следующее:

Стандартный товар


Поскольку свойства объектов были определены как public, мы можем считывать их значения, а также присваивать им новые начения, заменяя тем самым набор стандартных значений, определенный в классе.
*/

$product1 = new ShopProduct2();
$product2 = new ShopProduct2();

$product1->title = "Собачье сердце";
$product2->title = "Ревизор";

/*
Объявляя и определяя свойство $title в классе ShopProduct, мы гарантируем, что при создании любого объекта типа ShopProduct это свойство будет присутствовать и его значение будет заранее определено. Это означает. что при таком предположении в коде, где используется данный класс, можно будет работать с любыми объектами типа ShopProduct. Но поскольку мы можем легко переопределить это свойство, значение $title может изменяться от одного объекта к другому.

На заметку. Код, в котором используется класс, функция или метод, обычно называют клиентом класса, функции или метода либо просто клиентским кодом. В последующих главах вы будете часто встречать этот термин.

На самом деле в РНР необязательно объявлять все свойства в классе. Свойства можно динамически добавлять к объекту следующим образом.
*/

$product1->arbitraryAddition = "Дополнительный параметр";

/*
Но нужно отметить, что этот способ присвоения свойств объектам считается дурным тоном в объектно-ориентированном программировании и почти никогда не используется.

На данном этапе наши объекты пока производят довольно тягостное впечатление. Когда нам понадобится работать со свойствами объекта. придется делать это извне объектов. Мы пришли к тому. что нужно как-то задавать и получать значения свойств объекта. Определение нескольких свойств для нескольких объектов часто становится довольно неприятной задачей.
*/

$product1                     = new ShopProduct2();
$product1->title              = "Собачье сердце";
$product1->producerMainName  = "Булгаков";
$product1->producerFirstName = "Михаил";
$product1->price             = 5.99;

/*
Здесь мы снова используем класс ShopProduct, переопределяя один за другим все стандартные значения его свойств, пока не определим всю информацию о товаре. А теперь, когда мы определили некоторые данные, можно к ним обратиться.
*/

print "Автор: {$product1->producerFirstName} "."{$product1->producerMainName}";

/*
В результате на выходе получим следующее:
Автор: Михаил Булгаков

У этого подхода к определению значений свойств есть несколько недостатков. Поскольку РНР позволяет определять свойства динамически, вы не получите предупреждения, если забудете, как называется имя свойства, или сделаете в нем опечатку.
Например, можно ошибочно записать строку
*/
$product1->producerMainName  = "Булгаков";

// как:

$product1->producerSecondName  = "Булгаков";

/*
С точки зрения интерпретатора РНР этот код абсолютно корректен, поэтому никакого предупреждения об ошибке мы не получим. Но когда понадобится вывести имя автора, мы получим неожиданные результаты .Еще одна проблема - наши объекты, в целом. слишком "нестрогие". Мы не обязаны определять название книги, цену или имя автора. Клиентский код может быть уверен. что эти свойства существуют. но, вполне вероятно, очень часто их стандартные значения не будут вас устраивать. В идеале следовало бы заставлять всякого, кто создает экземпляры объекта ShopProduct, определять осмысленные значения его свойств. И наконец мы должны потратить уйму сил, чтобы сделать то, что, вероятно, придется делать очень часто. Вывести полное имя автора - это довольно трудоемкий и нудный процесс.
*/

print "Автор: {$product1->producerFirstName} "."{$product1->producerMainName}";

/*
И было бы прекрасно, если бы объект делал это вместо нас. Все эти проблемы можно решить, если снабдить объект ShopProduct собственным набором функций, которые можно использовать для выполнения операций над данными внутри контекста объекта.


Работа с методами
Так же, как свойства позволяют объектам сохранять данные, методы позволяют объектам выполнять задачи. Методы (methods) - это специальные функции, которые объявляются внутри класса. Как и можно было ожидать, объявление метода напоминает объявление функции. За ключевым словом function следует имя метода, а за ним - необязательный список переменных-аргументов в круглых скобках. Тело метода заключается в фигурные скобки.


public function myMethod($argument, $another) {
	//...
}


В отличие от функций, методы необходимо объявлять в теле класса. При этом можно также указывать ряд спецификаторов, в том числе ключевое слово, определяющее видимость метода. Как и свойства, методы можно определять как public, protected или private. Объявляя метод как public, мы тем самым обеспечиваем возможность его вызова извне текущего объекта. Если в определении метода вы опустите ключевое слово, определяющее видимость, то метод будет объявлен неявно как public. К модификаторам методов мы вернемся позже в этой главе.

На заметку. РНР 4 не распознает ключевые слова, определяющие видимость, для методов и свойств. Добавление к объявлению метода ключевых слов public, protected или private приведет к неустранимой ошибке. Все методы в РНР 4 неявно относятся к типу public.

В большинстве случаев метод вызывают с помощью объектной переменной, за которой указываются символы ' -> ' и имя метода. При вызове метода нужно использовать круглые скобки, так же как при вызове функции (даже если методу не передаются никакие аргументы).


$myObj = new MyClass();
$myObj->myMethod("Михаил", "Булгаков");

Давайте добавим методы к определенному ранее классу ShopProduct .
*/

class ShopProduct3 {
	public $title             = "Стандартный товар";
	public $producerMainName  = "Фамилия автора";
	public $producerFirstName = "Имя автора";
	public $price             = 0;

	function getProducer(){
		return "{$this->producerFirstName} "."{$this->producerMainName}";
	}
}

$product1 = new ShopProduct3();
$product1->title             = "Собачье сердце";
$product1->producerMainName  = "Булгаков";
$product1->producerFirstName = "Михаил";
$product1->price             = 5.99;

print"Автор: {$product1->getProducer()}";

/*
В результате на выходе получим следующее.
Автор: Михаил Булгаков

Мы добавили метод getProducer() к классу ShopProduct. Обратите внимание на то, что при определении метода мы не использовали ключевое слово, определяющее его видимость. Это означает, что метод get Producer() относится к типу public и его можно вызвать из-за пределов класса.
При определении метода getProducer() мы воспользовались новой возможностью - псевдопеременной $this. Она представляет собой механизм посредством которого из кода класса можно обратиться к экземпляру объекта. Если вы считаете, что это трудно для понимания, попробуйте заменить $this "текущим экземпляром объекта". Тогда оператор 
$this->producerFirstName
превратится в 
Свойство $producerFirstName текущего экземпляра объекта

Так, метод getProducer() объединяет и возвращает значения свойств $producerFirstName и $producerMainName, избавляя нас от неприятной работы всякий раз, когда нужно вывести полное имя автора.

Итак, нам удалось немного улучшить наш класс. Но для него по-прежнему характерна слишком большая "гибкость". Мы полагаемся на то, что программист будет изменять стандартные значения свойств объекта ShopProduct. Но это проблематично в двух отношениях. Во-первых, нужно пять строк кода, чтобы должным образом инициализировать объект типа ShopProduct, и ни один программист вам не скажет за это "спасибо". Во-вторых, у нас нет способа гарантировать, что какое-либо свойство будет определено при инициализации объекта ShopProduct. Поэтому нам нужен метод, который будет вызываться автоматически при создании экземпляра объекта на основе класса. 

Создание метода конструктора

Метод конструктора вызывается при создании объекта. Его можно использовать, чтобы все настроить, обеспечить определенные значения необходимых свойств и выполнить всю предварительную работу.

До РНР 5 имя метода конструктора совпадало с именем класса, к которому оно относилось. Так, класс ShopProduct мог использовать метод ShopProduct() в качестве своего конструктора.

В РНР 5 вы должны назвать метод конструктора __соnstruсt(). Обратите внимание на то, что имя метода начинается с двух символов подчеркивания. Это правило наименования действует для многих других специальных методов в РНР-классах.
Давайте определим конструктор для класса ShopProduct.
*/

class ShopProduct4 {
	public $title             = "Стандартный товар";
	public $producerMainName  = "Фамилия автора";
	public $producerFirstName = "Имя автора";
	public $price             = 0;

	function __construct($title, $FirstName, $MainName, $price) {
		$this->title             = $title;
		$this->producerFirstName = $FirstName;
		$this->producerMainName  = $MainName;
		$this->price             = $price;
	}

	function getProducer(){
		return "{$this->producerFirstName} "."{$this->producerMainName}";
	}
}


/*
И снова мы добавляем к классу функциональность, стараясь сэкономить время и силы программиста и избавить его от необходимости дублирования кода, работающего с этим классом. Meтoд __соnstruсt() вызывается, когда создается объект с помощью оператора new.
*/

$product1 = new ShopProduct4("Собачье сердце", "Михаил", "Булгаков", 5.99);
print "Автор: {$product1->getProducer()}";

/*
В результате получаем следующее.
Автор : Михаил Булгаков

Значения всех перечисленных аргументов передаются конструктору. Так, в нашем примере мы передаем конструктору название произведения, имя и фамилию автора, а также цену. В методе конструктора используется псевдопеременная $this для присвоения значений соответствующим свойствам объекта.

На заметку. В РНР 4 метод construct() не распознается в качестве конструктора. Если вы используете РНР 4, то для создания конструктора объявите метод, имя которого совпадает с именем содержащего его класса. Поэтому для класса с именем ShopProduct можно объявить конструктор с помощью метода под названием ShopProduct().
В РНР по-прежнему поддерживается эта схема именования конструктора. Но если вам не нужна совместимость со старыми версиями РНР, то методы конструктора лучше называть __construct().

Теперь стало безопаснее использовать объект ShopProduct и легче создавать экземпляры на основе его класса. Создание экземпляров и определение значений свойств выполняются в одном операторе. При написании любого кода, в котором
используется объект ShopProduct, можно быть уверенным, что все свойства этого объекта будут инициализированы.

Очень важным аспектом объектно-ориентированного программирования является предсказуемость. Вы должны так разрабатывать классы, чтобы пользователи объектов могли легко догадаться об их функциональных возможностях. Кроме того, при использовании объекта вы должны быть уверены в его типе. В следующем разделе мы изучим механизм, который можно использовать для явного определения типов объектов при объявлении методов.

Аргументы и типы
Типы определяют, каким способом можно оперировать данными в сценариях. Например, строковый тип используется для хранения и отображения символьных данных, а также для выполнения операций над такими данными с помощью строковых функций. Целые числа используются в математических выражениях, булевы числа - в логических выражениях и т.д. Эти категории называются элементарными типами данных. Класс также определяет тип имени себя, но на более высоком уровне. Поэтому объект ShopProduct относится к элементарному типу object, а также к типу класса ShopProduct. В данном разделе мы рассмотрим обе разновидности
типов в отношении методов класса.
При определении метода и функции не требуется, чтобы аргумент был определенного типа. Но это одновременно и преимущество, и недостаток. То, что аргумент может быть любого типа, дает широкое поле действий. Благодаря этому можно создавать методы, которые будут гибко обрабатывать данные различных типов и приспосабливать свою функциональность к меняющимся обстоятельствам. Но эта гибкость, с другой стороны, может стать причиной неопределенности в коде, когда тело метода ожидает один тип аргумента, а получает - другой.

Элементарные типы
РНР является слабо типизированным языком. Это означает, что нет необходимости объявлять тип данных, который должна хранить переменная. Так, в пределах одной и той же области видимости переменная $number может содержать как значение 2, так и строку "two" ("два"). В строго типизированных языках программирования, таких как С или Java, вы обязаны определить тип переменной, прежде чем присваивать ей значение, и, конечно, это значение должно быть указанного типа.Но это не означает, что в РНР нет понятия типа. Каждое значение, которое можно присвоить переменной, имеет свой тип. Вы можете определить тип значения
переменной с помощью одной из функций проверки типов языка РНР. В табл. 3.1 перечислены элементарные типы данных, используемые в РНР, и соответствующие им функции проверки. Каждой функции передается переменная или значение, а она возвращает значение true ("истина"), если аргумент относится к соответствующему типу.

Таблица 3.1. Элементарные типы данных и функции проверки в РНР

Функция проверки	   Тип         Описание

is_bool()            Boolean     Одно из двух значений: true или false (истина или ложь)       
is integer()         Integer     Целое число; является псевдонимом функций is_int() и is_long()
is_double()          Doble       Число с плавающей точкой (десятичное число); является псевдонимом функции is_float()
is_string()          String      Символьные данные
is_object()          Object      Объект
is_array()           Array       Массив
is_resource()        Resource    Дескриптор, используемый для идентификации и работы с внешними ресурсами, такими как базы
                                 данных или файлы
is_null()            Null        Неинициализированное значение


Проверка типа переменной особенно важна, когда вы работаете с аргументами в методе или функции.

Пример использования элементарных типов данных
Имейте в виду, что вы должны внимательно следить за типами данных в коде. Давайте рассмотрим пример одной из многих проблем, связанных с типами, с которой вы можете столкнуться.
Предположим, вам нужно извлечь параметры конфигурации из ХМL-файла. ХМL-элемент <resolvedomains> говорит приложению о том, следует ли пытаться преобразовывать IР-адреса в доменные имена. Надо отметить, что такое преобразование полезно, однако отнимает много времени. Вот фрагмент ХМL-кода:

<settings>
<resolvedomains>false</resolvedomains>
</settings>

Приложение извлекает строку "false" и передает ее в качестве параметра методу outputAddresses(), который выводит данные IР-адресов. Вот определение метода outputAddresses().
*/

class AdressManager {
	private $addresses = array("209.131.36.159", "74.125.19.106");
	function outputAddresses($resolve) {
		foreach ($this->addresses as $address) {
			print $address;
			if($resolve) {
				print "(" . gethostbyaddr($address) . ")";
			}
			print "";
		}
	}
}

/*
Разумеется, в код класса AddressManager можно внести ряд улучшений. Например, очень неудобно кодировать IР-адреса в виде массива внутри кода класса.
Несмотря на это метод outputAddresses() циклически проходит по массиву IР-адресов и выводит его элементы один за другим. Если значение аргумента $resolve равно true, то метод, кроме IР-адресов, выводит также доменные имена.

Ниже приведен один из возможных вариантов использования класса AddressManager совместно с тегом settings ХМL-файла конфигурации. Сможете ли вы сходу определить ошибку в приведенном ниже коде?


$settings = simplexml_load_file("settings.xml");
$manager = new AddressManager();
$manager->outputAddresses((string) $settings->resolvedomains);


В этом фрагменте кода для получения значения элемента resolveedomains используется SimpleXМLAPI, который появился в РНР 5. В нашем примере мы знаем, что это значение - текстовый элемент "false", и преобразуем его в строку, поскольку так советуют в документации по SimpleXМL.
Но этот код будет работать не так, как вы того ожидаете. Передавая строку "false" методу outputAddresses(), мы точно не знаем, какой тип аргумента используется в методе по умолчанию. Данный метод ожидает булеву величину, которая может принимать значение true (истина) или false (ложь). При выполнении условного оператора строка "false" на самом деле превратится в значение true. Все дело в том, что при выполнении проверки интерпретатор РНР "заботливо" преобразует непустое строковое значение в булево значение true. Поэтому

if("false") {
	//...
}
эквивалентно следующему:
if(true) {
	//...
}
Исправить эту ситуацию можно по-разному. Во-первых, можно сделать метод outputAddresses() менее требовательным, чтобы он распознавал строку и применял некоторые основные правила для ее преобразования в булев эквивалент.


function outputAddresses($resolve) {
			if(is_string($resolve)) {
				$resolve = (preg_match("/false|no|off/i", $resolve)) ? false:true;
			}

Тем не менее с точки зрения проектирования существуют достаточно веские причины избегать приведенного выше решения. В сущности, лучше всего при проектировании метода или функции предусматривать для них строгий интерфейс, избегающий
двусмысленности, и не заниматься реализацией мутного и всепрощающего функционала. Подобные решения рано или поздно вызывают путаницу и становятся источником ошибок.
Во-вторых, можно оставить метод outputAddresses() таким, как есть, и включить комментарий с четкими инструкциями о том, что аргумент $resolve должен содержать булево значение. Этот подход, по сути, говорит программисту о том, что нужно внимательно читать инструкции или пенять на себя.

* Выводит список адресов.
* Если переменная $resolve содержит истинное значение (true),
* то адрес преобразуется в эквивалентное имя хоста.
* @param $resolve Boolean Преобразовать адрес?


function outputAddresses($resolve) {
	//...
}

Это вполне разумное решение, если вы точно уверены в том, что программисты, использующие ваш класс, добросовестно прочтут документацию к нему.

И наконец, в-третьих, можно сделать метод outputAddresses() строгим в отношении типа данных аргумента $resolve.

function outputAddresses($resolve) {
			if(!is_bool($resolve)) {
				die ("Методу outputAddress() требуется булев аргумент ");
			}

Этот подход заставляет клиентский код обеспечить корректный тип данных для аргумента $resolve. Преобразование строкового аргумента в клиентском коде - более дружественный подход, но, вероятно, он может вызвать другие проблемы.
Обеспечивая механизм преобразования в методе, мы предугадываем контекст его использования и намерение клиента. С другой стороны, навязывая булев тип данных, мы предоставляем клиенту право выбора - преобразовывать ли строки в булев
тип и какое слово какому значению будет соответствовать. А между тем метод outputAddresses() разрабатывался с целью решить конкретную задачу. Этот акцент на выполнении конкретной задачи при намеренном игнорировании более широкого контекста - важный принцип объектно-ориентированного программирования, к которому мы будем часто возвращаться в этой книге.

На самом деле стратегии работы с типами аргументов зависят от степени серьезности возможных ошибок. РНР автоматически преобразовывает большинство элементарных значений в зависимости от контекста. Например, если числа в строках используются в математических выражениях, то они преобразуются в эквиваленты целых значений или значений с плавающей точкой. В результате код будет "снисходителен" к некорректному типу аргумента. Но если вы рассчитываете, что один из аргументов метода будет массивом, то нужно проявить большую осторожность.

Передача "немассивного" значения одной из функций массивов РНР не приведет к хорошим результатам и вызовет ряд ошибок в методе.
Поэтому, вполне вероятно, вы примените свой подход и найдете нечто среднее между проверкой типа, преобразованием из одного типа в другой и надеждой на хорошую, понятную документацию (причем документацию вы должны предоставить независимо от того, какой способ предпочтете).
Как бы вы ни решали проблемы подобного рода, можете быть уверены в одном - тип аргумента всегда имеет значение! То, что язык РНР не является строго типизированным, делает эту проблему еще более важной. Нельзя полагаться на компилятор
в вопросе предотвращения ошибок, связанных с типом. Поэтому вы должны предусмотреть возможные последствия того, что типы аргументов окажутся не такими, как ожидалось. Не стоит надеяться, что программисты клиентского кода будут читать ваши мысли. И вы всегда должны учитывать, как в создаваемых вами методах будут обрабатываться входные данные, имеющие некорректный тип.

Уточнения типов объектов
Мы уже говорили, что переменная-аргумент может содержать любой элементарный тип данных, однако по умолчанию ее тип не оговаривается, поэтому она может содержать объект любого типа. Такая гибкость, с одной стороны, полезна, но, с другой,
может стать причиной проблем при определении метода.
Рассмотрим метод, предназначенный для работы с объектом типа ShopProduct.
*/

class ShopProductWriter {
	public function write($shopProduct){
		$str = "{$shopProduct->title}: " . $shopProduct->getProducer() . "({$shopProduct->price})";
		print $str;
	}
}

// Мы можем протестировать этот класс следующим образом.

$product1 = new ShopProduct4("Собачье сердце", "Михаил", "Булгаков", 5.99);
$writer = new ShopProductWriter();
$writer->write($product1);

//Тогда на выходе получим следующее: Собачье сердце: Михаил Булгаков(5.99)

/*
Класс ShopProductWriter содержит единственный метод, write(). Методу write() передается объект типа ShopProduct. В нем используются свойства и методы последнего для построения и вывода результирующей строки описания товара. Мы используем имя переменной-аргумента, $shopProduct, как напоминание программисту о том, что методу write() нужно передать объект типа ShopProduct. Но это требование не является обязательным. Это значит, что я могу передать некорректный объект или элементарный тип методу write() и ничего об этом не узнать до момента обращения к аргументу $shopProduct. К тому времени в нашем коде уже могут быть выполнены какие-либо действия так, как если бы мы передали методу настоящий объект типа ShopProduct.

На заметку. Возможно, вас заинтересует, почему мы не добавили метод write() непосредственно в класс ShopProduct. Вообще говоря, проектным решениям подобного рода, в числе прочего, посвящена и эта глава, и целая книга. А ответом на поставленный вопрос будет следующее: все дело в ответственности. Класс ShopProduct ответственен за хранение данных о товаре, а класс ShopProductWriter - за вывод этих данных. По мере чтения этой главы вы начнете понимать, в чем польза такого разделения ответственности.

Для решения описанной проблемы, в РНР 5 появилась новая возможность - уточнение типов данных класса. Чтобы добавить уточнение типа к арrументу метода, просто поместите перед ним имя класса. Поэтому метод write() можно изменить следующим образом:

public function write(ShopProduct $shopProduct) {
	//...
}

Теперь методу write() можно передавать арrумент $shopProduct, содержащий только объект типа ShopProduct. Давайте попробуем вызвать метод write() для такого "хитрого" объекта.

class Wrong {}
$writer = new ShopProductWriter();
$writer->write(new Wrong());

Поскольку метод write() содержит уточнение типа класса, передача ему объекта Wrong приведет к неустранимой ошибке.

/*
Fatal error: Call to undefined method Wrong::getProducer() in D:\_OpenServer_5_2_4\OpenServer\domains\Zandstra-php\class.php 

Теперь нам не нужно каждый раз при вызове метода проверять тип передаваемого ему аргумента. Кроме того, использование уточнений делает запись метода намного понятнее для программиста клиентского кода. Он сразу же увидит требования метода write(). Программисту не нужно будет волноваться по поводу незаметных ошибок, возникающих в результате несоответствия типов арrументов, поскольку благодаря уточнению они определяются принудительно и строго.

Хотя автоматическая проверка типов - это превосходный способ предотвращения ошибок, важно понимать, что уточнения проверяются во время выполнения программы. Это означает, что уточнение класса сообщит об ошибке только тогда, когда нежелательный объект будет передан методу. И если вызов метода write() находится где-то глубоко в условном операторе, который запускается только на Рождество, то, если вы тщательно не проверили код, вам придется работать на праздники.

Уточнения нельзя использовать для принудительного определения арrументов элементарных типов, таких как строки и целые значения. Для этой цели в теле методов следует использовать функции проверки типов, такие как isint(). Но можно принудительно определить, что аргумент является массивом:
*/

function setArray(array $storearray) {
	$this->array = $storearray;
}

/*
Поддержка уточнения для массивов была добавлена в РНР начиная с версии 5.1. В дальнейшем также была добавлена поддержка нулевых стандартных значений в арrументах с уточнениями. Это означает, что можно требовать, чтобы арrумент был либо определенного типа, либо нулевым значением. Вот как это сделать:

*/

function setWriter(ObjectWriter $objwriter = null) {
	$this->writer = $objwriter;
}

/*
До сих пор мы обсуждали типы и классы так, как будто это синонимы. Но между ними есть коренное различие. При определении класса вы определяете также и тип, но тип может описывать целое семейство классов. Механизм, посредством которого различные классы можно группировать под одним типом, называется наследованием.
О наследовании мы и поговорим в следующем разделе.


Наследование

Наследование - это механизм, посредством которого один или несколько классов можно получить из некоторого базового класса.

Класс, который получается в результате наследования от другого, называется его подклассом. Эту связь обычно описывают с помощью терминов "родительский" и "дочерний". Дочерний класс происходит от родительского и наследует его характеристики.
Эти характеристики состоят из свойств и методов. Обычно в дочернем классе к функциональности родительского класса (который также называют суперклассом) добавляются новые функциональные возможности. Поэтому говорят, что дочерний класс расширяет родительский.
Прежде чем приступить к изучению синтаксиса наследования, давайте рассмотрим проблемы, которые оно поможет нам решить.

Проблема наследования
Давайте вернемся к классу ShopProduct. В настоящее время он является достаточно обобщенным. С его помощью можно оперировать самыми разными товарами.
*/

$product1 = new ShopProduct4("Собачье сердце", "Михаил", "Булгаков", 5.99);
$product2 = new ShopProduct4("Пропавший без вести", "Группа", "ДДТ", 10.99);

print "Автор: " . $product1->getProducer() ."";
print "Исполнитель: " . $product2->getProducer() . "";

/*
На выходе получаем следующее:
Автор: Михаил Булгаков 
Исполнитель: Группа ДДТ

Как видим, разделение имени автора на две части пригодилось нам при работе и с книгами, и с компакт-дисками. В этом случае мы можем сортировать товары по фамилии автора (т.е. по полю, содержащему " Булгаков" и "ДДТ") , а не по имени, в
котором содержатся малозначимые "Михаил" и "Группа". Лень - это отличная стратегия проектирования, поэтому на данном этапе вам не следует заботиться об использовании класса ShopProduct для более чем одного типа товара. Но если в нашем примере добавить несколько новых требований, то все сразу усложнится. Представьте, например, что вам нужно отобразить данные, специфичные для книг и компакт-дисков. Скажем, для CD желательно вывести общее время звучания, а для книг - количество страниц. Конечно, могут быть и другие отличия, но эти хорошо иллюстрируют суть проблемы. Как расширить наш пример. чтобы учесть все эти изменения? На ум сразу приходят два варианта. Во-первых, можно поместить все данные в класс ShopProduct.
Во-вторых, можно разбить ShopProduct на два отдельных класса.

Давайте рассмотрим первый подход. Итак, мы объединяем данные о книгах и компакт-дисках в одном классе.
*/

class ShopProduct5 {
	public $numPages;
	public $playLength;
	public $title;
	public $producerMainName;
	public $producerFirstName;
	public $price;

	function __construct($title, $FirstName, $MainName, $price, $numPages = 0, $playLength = 0) {
		$this->title             = $title;
		$this->producerFirstName = $FirstName;
		$this->producerMainName  = $MainName;
		$this->price             = $price;
		$this->numPages          = $numPages;
		$this->playLength        = $playLength;
	}

	function getNumberOfPages(){
		return $this->numPages;
	}

	function getPlayLength(){
		return $this->playLength;
	}

	function getProducer(){
		return "{$this->producerFirstName} "."{$this->producerMainName}";
	}
}

/*
Чтобы продемонстрировать большой объем выполняемой работы по кодированию, в данном примере были использованы методы доступа к свойствам $numPages и $playLength. В результате объект, экземпляр которого создается с помощью такого класса, будет всегда содержать избыточные методы. Кроме того, для CD экземпляр объекта нужно создавать с помощью бессмысленного аргумента конструктора.

Таким образом, для CD будут сохраняться информация и функциональные возможности класса, относящиеся к книгам (количество страниц), а для книг - данные о времени звучания CD. Вероятно, пока вы можете с этим смириться. Но что будет,
если мы добавим больше типов товаров, причем каждый - с собственными методами, а затем добавим больше методов для каждого типа? Наш класс будет становиться все более сложным и трудным для использования.

Поэтому принудительное объединение полей, относящихся к разным товарам, в один класс приведет к созданию слишком громоздких объектов с лишними свойствами и методами.

Но этим проблемы не ограничиваются. С функциональностью тоже возникнут трудности. Представьте метод, который выводит краткую информацию о товаре.
Скажем, отделу продаж нужна информация о товаре в виде одной строки для использования в счете-фактуре. Они хотят, чтобы мы включили в нее время звучания для компакт-диска и количество страниц для книги. Таким образом, при реализации
этого метода нам придется учитывать тип каждого товара. Для отслеживания формата объекта можно использовать специальный флаг. Приведем пример.
*/

function getSummaryLine() {
	$base = "{$this->title} ({$this->producerMainName}, ";
	$base .= "{$this->producerFirstName} )";
	if($this->type == 'book') {
		$base .=  ": {$this->numPages} стр.";
	} else if($this->type == 'cd'){
		$base .= ": Время звучания - {$this->playLength}";
	}
	return $base;
}


/*
Как видите, чтобы правильно установить значение свойства $type, нам нужно в конструкторе проверить значение аргумента 
$numPages. И снова класс ShopProduct стал более сложным, чем нужно. По мере добавления дополнительных отличий в форматы или новых форматов нам будет трудно справляться с реализацией этого метода. Поэтому, видимо, для решения данной задачи  необходимо применить второй подход.
Поскольку ShopProduct начинает напоминать "два класса в одном", мы должны это признать и создать два типа вместо одного. Вот как это можно сделать.
*/

class CDProduct {
	public $playLength;
	public $title;
	public $producerMainName;
	public $producerFirstName;
	public $price;

	function __construct($title, $FirstName, $MainName, $price, $playLength) {
		$this->title             = $title;
		$this->producerFirstName = $FirstName;
		$this->producerMainName  = $MainName;
		$this->price             = $price;
		$this->playLength        = $playLength;
	}

	function getPlayLength(){
		return $this->playLength;
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		$base .= ": Время звучания - {$this->playLength}";
		return $base;
	}

	function getProducer(){
		return "{$this->producerFirstName} "."{$this->producerMainName}";
	}
}

class BookProduct {
	public $numPages;
	public $title;
	public $producerMainName;
	public $producerFirstName;
	public $price;

	function __construct($title, $FirstName, $MainName, $price, $numPages) {
		$this->title             = $title;
		$this->producerFirstName = $FirstName;
		$this->producerMainName  = $MainName;
		$this->price             = $price;
		$this->numPages          = $numPages;
	}

	function getNumberOfPages(){
		return $this->numPages;
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		$base .=  ": {$this->numPages} стр.";
		return $base;
	}

	function getProducer(){
		return "{$this->producerFirstName} "."{$this->producerMainName}";
	}
}

/*
Мы постарались справиться с этой сложностью, хотя пришлось кое-чем пожертвовать. Теперь мы можем создать метод getSummaryLine() для каждого типа товара, причем нам даже не нужно проверять значение специального флага. И больше ни
один класс не содержит поля или методы, которые не имеют к нему отношения.
А жертва состояла в дублировании. Методы getProducer() абсолютно одинаковы для каждого класса. Каждый конструктор одинаково устанавливает ряд идентичных свойств. Это еще один признак дурного тона, и вы должны этого избегать.
Если нужно, чтобы методы getProducer() работали одинаково для каждого класса, любые изменения, внесенные в одну реализацию, должны быть внесены и в другую.
Но так мы довольно скоро нарушим синхронизацию классов.

Даже если мы уверены. что можем поддерживать дублирование, на этом наши проблемы не закончатся. Ведь у нас теперь есть два типа, а не один.
Помните класс ShopProductWriter? Его метод write() предназначен для работы с одним типом: ShopProduct. Как выйти из сложившейся ситуации, чтобы все работало, как раньше? Мы можем удалить уточнение типа класса из объявления метода, но тогда мы должны надеяться, что методу write() будет передан объект правильного типа. Мы можем добавить в тело метода собственный код для проверки типа.
*/

class ShopProductWriter2 {
	public function write($shopProduct){
		if(!($shopProduct instanceOf CDProduct) && !($shopProduct instanceOf BookProduct)){
			die("Передан неверный тиn данных");
		}
		$str = "{$shopProduct->title}: " . $shopProduct->getProducer() . "({$shopProduct->price})";
		print $str;
	}
}

/*
Обратите внимание на оператор instanceOf, использованный в этом примере. Вместо него подставляется значение true (истина), если объект в операнде слева относится к типу, представляемому операндом справа.

И снова мы были вынуждены добавить новый уровень сложности. Нам нужно не только проверять аргумент $shopProduct на соответствие двум типам в методе write(), но и надеяться, что в каждом типе будут поддерживаться те же поля и методы, что и в другом. Согласитесь, иметь только один тип было бы гораздо лучше. Тогда мы могли бы использовать уточнение типа класса для аргумента метода write(), и мы были бы уверены в том, что класс ShopProduct поддерживает нужный нам интерфейс.

Особенности класса ShopProduct, связанные с книгами и CD, плохо работают вместе, но, похоже, не могут существовать по отдельности. Нам нужно работать с книгами и CD как с одним типом, но в то же время обеспечить отдельную реализацию
метода для каждого формата вывода. Нам нужно создать общую функциональность в одном месте, чтобы избежать дублирования, но в то же время сделать так, чтобы при вызове метода, выводящего краткую информацию о товаре, учитывались особенности этого товара. Одним словом, нам необходимо использовать наследование.
*/

echo "<br><br>";
$product1 = new ShopProductWriter2();
$cdProduct = new CDProduct("60 min", "Пропавший без вести", "Группа", "ДДТ", 10.99);
print $product1->write($cdProduct);

/*
Работа с наследованием
Первый шаг в построении дерева наследования - найти элементы базового класса, которые не соответствуют друг другу или которыми нужно оперировать иначе.
Мы знаем, что методы getPlayLength() и getNumberOfPages() противоречат один другому. Нам также известно, что нужно создать разные реализации метода getSummaryLine(). Давайте используем эти различия, как основу для создания двух производных
классов.
*/

class ShopProduct6 {
	public $numPages;
	public $playLength;
	public $title;
	public $producerMainName;
	public $producerFirstName;
	public $price;

	function __construct($title, $FirstName, $MainName, $price, $numPages = 0, $playLength = 0) {
		$this->title             = $title;
		$this->producerFirstName = $FirstName;
		$this->producerMainName  = $MainName;
		$this->price             = $price;
		$this->numPages          = $numPages;
		$this->playLength        = $playLength;
	}

	function getProducer(){
		return "{$this->producerFirstName} "."{$this->producerMainName}";
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		return $base;
	}
}

class CDProduct2 extends ShopProduct6  {
	function getPlayLength(){
		return $this->playLength;
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		$base .= ": Время звучания - {$this->playLength}";
		return $base;
	}
}

class BookProduct2 extends ShopProduct6 {
	function getNumberOfPages(){
		return $this->numPages;
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		$base .=  ": {$this->numPages} стр.";
		return $base;
	}
}

/*
Чтобы создать дочерний класс, необходимо использовать в объявлении класса ключевое слово extends. В данном примере мы создали два новых класса, BookProduct и CDProduct. Оба они расширяют класс ShopProduct.

Поскольку в производных классах конструкторы не определяются, при создании экземпляров объектов этих классов будет автоматически вызываться конструктор родительского класса. Дочерние классы наследуют доступ ко всем методам типа public и protected родительского класса (но не к методам и свойствам типа private).
Это означает, что мы можем вызвать метод getProducer() для экземпляра объекта класса CDProduct, хотя метод getProducer() определен в классе ShopProduct.
*/
echo "<br><br>";
$product2 = new CDProduct2("Пропавший без вести", "Группа", "ДДТ", 10.99, null, 60.33);
print "Исполнитель: {$product2->getProducer()}";


/*
Таким образом, оба наших дочерних класса наследуют поведение общего родительского класса. И мы можем обращаться с объектом BookProduct так, как будто это объект типа ShopProduct. Мы можем передать объект BookProduct или CDProduct методу write() класса ShopProductWriter, и все будет работать как надо.

Обратите внимание на то, что для обеспечения собственной реализации в обоих классах, CDProduct и BookProduct, переопределяется метод getSummaryLine(). Производные классы могут расширять и изменять функциональность родительских
классов. И в то же время каждый класс наследует свойства родительского класса.

Реализация метода getSummaryLine() в суперклассе может показаться избыточной, поскольку метод переопределяется в обоих дочерних классах. Тем не менее мы предоставляем базовый набор функциональных возможностей, который можно будет
использовать в любом новом дочернем классе. Наличие этого метода в суперклассе также гарантирует для клиентского кода, что во всех объектах типа ShopProduct будет присутствовать метод getSummaryLine(). Позже вы увидите, как можно выполнить это требование в базовом классе, не предоставляя никакой его реализации. Каждый дочерний объект класса ShopProduct унаследует все свойства своего родителя. В собственных реализациях метода getSummaryLine() для обоих классов, CDProduct и BookProduct, обеспечивается доступ к свойству $title.

С понятием наследования сразу разобраться непросто. Определяя класс, который расширяет другой класс, мы гарантируем, что экземпляр его объекта определяется характеристиками сначала дочернего, а затем - родительского класса. Чтобы понять это, нужно размышлять с точки зрения поиска. При вызове $product2->getProducer() интерпретатор РНР не может найти такой метод в классе CDProduct. Поиск заканчивается неудачей, и поэтому используется стандартная реализация этого метода, заданная в классе ShopProduct. С другой стороны, когда мы вызываем $product2->getSummaryLine(), интерпретатор РНР находит реализацию метода getSummaryLine() в классе CDProduct и вызывает его.

То же самое верно и в отношении доступа к свойствам. При обращении к свойству $title в методе getSummaryLine() из класса BookProduct интерпретатор РНР не находит определение этого свойства в классе BookProduct. Поэтому он использует
определение данного свойства, заданное в родительском классе ShopProduct. Поскольку свойство $title используется в обоих подклассах, оно должно определяться в суперклассе.

Даже поверхностного взгляда на конструктор ShopProduct достаточно, чтобы понять, что в базовом классе по-прежнему выполняется обработка тех данных, которыми должен оперировать дочерний класс. Так, конструктору класса BookProduct должен передаваться аргумент $numPages, значение которого заносится в одноименное свойство, а конструктор класса CDProduct должен обрабатывать аргумент и свойство $playLength. Чтобы добиться этого, мы определим методы конструктора в каждом дочернем классе.


Конструкторы и наследование

При определении конструктора в дочернем классе вы берете на себя ответственность за передачу требуемых аргументов родительскому классу. Если же вы этого не сделаете, то у вас получится частично сконструированный объект. Чтобы вызвать нужный метод родительского класса, вам понадобится обратиться к самому этому классу через дескриптор. Для этой цели в РНР предусмотрено ключевое слово parent.
Чтобы обратиться к методу в контексте класса, а не объекта, следует использовать символы "::", а не "->". 

Поэтому конструкция:


parent::__construct() // Означает следующее: "Вызвать мeтoд __construct() родительского класса".


Давайте изменим наш пример так, чтобы каждый класс оперировал только теми данными, которые имеют к нему отношение.
*/

class ShopProduct7 {
	public $title;
	public $producerMainName;
	public $producerFirstName;
	public $price;

	function __construct($title, $FirstName, $MainName, $price, $numPages = 0, $playLength = 0) {
		$this->title             = $title;
		$this->producerFirstName = $FirstName;
		$this->producerMainName  = $MainName;
		$this->price             = $price;
	}

	function getProducer() {
		return "{$this->producerFirstName} "."{$this->producerMainName}";
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		return $base;
	}
}

class CDProduct3 extends ShopProduct7  {
	public $playLength;

	function __construct($title, $FirstName, $MainName, $price, $playLength) {
		parent::__construct($title, $FirstName, $MainName, $price);
		$this->playLength = $playLength;
	}

	function getPlayLength() {
		return $this->playLength;
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		$base .= ": Время звучания - {$this->playLength}";
		return $base;
	}
}

class BookProduct3 extends ShopProduct7 {
	public $numPages;

	function __construct($title, $FirstName, $MainName, $price, $numPages) {
		parent::__construct($title, $FirstName, $MainName, $price);
		$this->numPages = $numPages;
	}

	function getNumberOfPages() {
		return $this->numPages;
	}

	function getSummaryLine() {
		$base = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		$base .=  ": {$this->numPages} стр.";
		return $base;
	}
}

/*
Каждый дочерний класс вызывает конструктор своего родительского класса, прежде чем определять собственные свойства. Базовый класс теперь "знает" только о собственных данных. Дочерние классы - это обычно "специализации" родительских классов. Как правило, следует избегать того, чтобы давать родительским классам какие-либо особые "знания" о дочерних классах.

На заметку. 
До появления РНР 5 имя функции конструктора совпадало с именем класса, к которому она относилась. В новой версии РНР для унификации используется имя функции конструктора __construct(). При использовании старого синтаксиса вызов конструктора родительского класса был привязан к имени конкретного класса, например parent::ShopProduct(); . В случае изменения иерархии классов это часто приводило к проблемам. Большинство ошибок возникало из-за того, что программисты, после непосредственного изменения "родителя" класса, забывали обновить сам конструктор. А при использовании унифицированного конструктора вызов родительского конструктора parent::__construct() означает обращение непосредственно к родительскому классу, независимо от
того, какие изменения произошли в иерархии классов. Но, конечно, нужно позаботиться о том, чтобы этому родительскому классу были переданы правильные аргументы!


Вызов переопределенного метода
Ключевое слово parent можно использовать в любом методе, который переопределяет свой эквивалент в родительском классе. Когда мы переопределяем метод, то, возможно, хотим не удалить функции "родителя", а, скорее, расширить их. Достичь этого можно, вызвав метод родительского класса в контексте текущего объекта.
Если вы снова посмотрите на реализации метода getSummaryLine(), то увидите, что значительная часть кода в них дублируется. И лучше этим воспользоваться, чем повторять функциональность, уже разработанную в классе ShopProduct.



Класс ShopProduct . . .
function getSummaryLine() {
	$base = "{$this->title} ({$this->producerMainName},";
	$base .= "{$this->producerFirstName})";
	return $base;
}
Класс BookProduct . . .
function getSummaryLine() {
	$base = parent::getSummaryLine();
	$base .= ": {$this->numPages} стр.";
	return $base;
}


Мы определили основные функции для метода getSummaryLine() в базовом классе ShopProduct. Вместо того чтобы повторять их в подклассах CDProduct и BookProduct, мы просто вызовем родительский метод, прежде чем добавлять дополнительные данные к итоговой строке.
Теперь, когда мы познакомились с основами наследования, можно, наконец, рассмотреть вопрос видимости свойств и методов в свете полной картины происходящего.


Public, Private и Protected: управление доступом к классам
До сих пор мы явно или неявно объявляли все свойства как Public (общедоступные). Такой тип доступа задан по умолчанию для всех методов, а также свойств, объявленных с использованием устаревшего ключевого слова var. Элементы класса можно объявить как public (общедоступные), private (закрытые) или protected (защищенные).

• К общедоступным (Public) свойствам и методам можно получать доступ из любого контекста.
• К закрытому (Private) свойству и методу можно получить доступ только из того класса, в котором они объявлены. Даже подклассы данного класса не имеют доступа к таким свойствам и методам.
• К защищенным (Protected) свойствам и методам можно получить доступ либо из содержащего их класса, либо из его подкласса. Никакому внешнему коду такой доступ не предоставляется.


Чем это может быть нам полезно? Ключевые слова, определяющие область видимости, позволяют показывать только те аспекты класса, которые требуются клиенту. Это позволяет создать ясный и понятный интерфейс для объекта. Контроль доступа, позволяющий запрещать клиенту доступ к некоторым свойствам, поможет также избежать ошибок в коде. Предположим, мы хотим сделать так, чтобы в объектах типа ShopProduct поддерживались скидки. Для этого можно добавить свойство $discount и метод setDiscount().


class ShopProduct...
public $discount = 0;
// ...
function setDiscount($num) {
	$this->discount = $num;
}


Вооруженные механизмом определения скидки, мы можем создать метод getPrice(), который принимает во внимание установленную скидку.


class ShopProduct...
function getPrice() {
	return ($this->price - $this->discount);
}

/*
Но тут у нас есть проблема. Мы хотим показать всем только скорректированную цену, но клиент может легко обойти метод getPrice() и получить доступ к свойству $price.
*/

print "Цена - {$product2->price}";

/*
В результате будет выведена исходная цена, а не цена со скидкой, которую мы хотим представить. Чтобы предотвратить это, можно просто закрыть свойство $price. Это позволит запретить клиентам прямой доступ к нему, заставляя использовать метод getPrice(). Любая попытка получить доступ к свойству $price из-за пределов класса ShopProduct закончится неудачей. В результате для внешнего мира это свойство прекратит существование.
Но определение свойств как private - не всегда удачная стратегия, поскольку тогда дочерний класс не сможет получить доступ к закрытым свойствам. А теперь представьте, что правила вашего бизнеса таковы: при покупке только книг скидку на них делать нельзя. Мы можем переопределить метод getPrice(), чтобы он возвращал свойство $price без применения скидки.

class BookProduct...
	function getPrice() {
		return $this->price;
	}

Поскольку свойство $price объявлено в классе ShopProduct, а не в BookProduct, попытка в приведенном выше коде получить к нему доступ закончится неудачей. Чтобы решить эту проблему, нужно объявить свойство $price защищенным (protected) и тем самым предоставить доступ к нему дочерним классам. Помните, что к защищенному свойству или методу нельзя получить доступ из-за пределов иерархии того класса, в котором это свойство или метод был объявлен. Доступ к ним можно получить только из исходного класса или его дочерних классов.

Как правило, появление ошибок при доступе к свойствам или методам способствует созданию хорошо защищенного кода. Сначала сделайте свойства закрытыми или защищенными, а затем ослабляйте ограничения по мере необходимости. Многие (если не все) методы в ваших классах будут общедоступными, но, повторяю еще раз, если у вас есть сомнения, ограничьте доступ. Метод, предоставляющий локальные функции другим методам в классе, не нужен пользователям класса. Поэтому сделайте его закрытым или защищенным.

Методы как средство доступа к свойствам
Даже если в клиентской программе нужно будет работать со значениями, хранящимися в экземпляре вашего класса, как правило, стоит запретить прямой доступ к свойствам этого объекта. Вместо этого создайте методы, которые возвращают или устанавливают нужные значения. Такие методы называют методами доступа (accessors) или получателями (getter) и установщиками (setter).

Вы уже видели одно преимущество, которое дают методы доступа: их можно использовать для фильтрации значений свойств в зависимости от обстоятельств, как было проиллюстрировано выше с помощью метода getPrice().

Метод-установщик может также использоваться для принудительного определения типа свойства. Мы уже видели, что для ограничения типа аргументов метода можно использовать уточнения, но у нас нет непосредственного контроля над типами свойств. Помните определение класса ShopProductWriter, с помощью которого выводилась информация об объектах типа ShopProduct? Давайте попробуем пойти дальше и сделать так, чтобы класс ShopProductWriter мог выводить информацию о любом количестве объектов типа ShopProduct одновременно.
*/

class ShopProductWriter3 {
	public $products = array();

	public function addProduct(ShopProduct $shopProduct) {
		$this->products[] = $shopProduct;
	}

	public function write() {
		$str = "";
		foreach ($this->products as $shopProduct) {
			$str .= "{$shopProduct->title}: ";
			$str .= $shopProduct->getProducer();
			$str .= " ({$shopProduct->getPrice()})";
		}
		print $str;
	}
}

/*
Теперь класс ShopProductWriter стал намного полезнее. Он может содержать много объектов типа ShopProduct и сразу выводить информацию обо всех них. Но мы все еще должны полагаться на то, что программисты клиентского кода будут строго придерживаться правил работы с классом. Хотя мы предоставили метод addProduct(), мы не запретили программистам непосредственно выполнять операции над свойством $products. В результате можно не только добавить объект неправильного
типа к массиву свойств $products, но и затереть весь массив и заменить его значением элементарного типа. Чтобы не допустить этого, нужно сделать свойство $products закрытым


class ShopProductWriter {
	private $products = array();
	//...
}

Теперь внешний код не сможет повредить массив свойств $products. Весь доступ к нему должен осуществляться через метод addProduct(), а уточнения типа класса, которые используются в объявлении этого метода, гарантируют, что к массиву свойств могут быть добавлены только объекты типа ShopProduct.

Семейство классов ShopProduct
И в заключение данной главы давайте изменим класс ShopProduct и его дочерние классы так, чтобы ограничить доступ к свойствам.
*/

class ShopProduct8 {
	private $title;
	private $producerMainName;
	private $producerFirstName;
	protected $price;
	private $discount = 0;

	public function __construct($title, $firstName, $mainName, $price) {
		$this->title             = $title;
		$this->producerFirstName = $firstName;
		$this->producerMainName  = $mainName;
		$this->price             = $price;
	}

	public function getProducerFirstName() {
		return $this->producerFirstName;
	}

	public function getProducerMainName() {
		return $this->producerMainName;
	}

	public function setDiscount($num) {
		$this->discount = $num;
	}

	public function getDiscount() {
		return $this->discount;
	}

	public function getTitle() {
		return $this->title;
	}

	public function getPrice() {
		return ($this->price - $this->discount);
	}

	public function getProducer() {
		return $this->producerFirstName . " " . $this->producerMainName;
	}

	public function getSummaryLine() {
		$base  = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		return $base;
	}
}


class CDProduct4 extends ShopProduct8 {
	private $playLength = 0;

	public function __construct($title, $fistName, $mainName, $price, $playLength) {
		parent::__construct($title, $fistName, $mainName, $price);
		$this->playLength = $playLength;
	}

	public function getPlayLength() {
		return $this->playLength;
	}

	public function getSummaryLine() {
		$base  = parent::getSummaryLine();
		$base .= ": Время звучания -{$this->playLength}";
		return $base;
	}
}

class BookProduct4 extends ShopProduct8 {
	private $numPages = 0;

	public function __construct($title, $fistName, $mainName, $price, $numPages) {
		parent::__construct($title, $fistName, $mainName, $price);
		$this->numPages = $numPages;
	}

	public function getNumberOfPages() {
		return $this->numPages;
	}

	public function getSummaryLine() {
		$base  = parent::getSummaryLine();
		$base .= ": {$this->numPages} стр.";
		return $base;
	}

	public function getPrice() {
		return $this->price;
	}
}

/*
В этой версии семейства классов ShopProduct нет ничего существенно нового. Все методы были явно сделаны общедоступными, а все свойства теперь стали либо закрытыми, либо защищенными. И для завершенности мы добавили ряд методов доступа.

Резюме
В этой главе мы подробно рассмотрели основы объектно-ориентированного программирования в РНР, превратив первоначально пустой класс в полностью функциональную иерархию наследования. Мы разобрались в некоторых вопросах проектирования, особенно касающихся типа и наследования. Вы также узнали о поддержке видимости в РНР и познакомились с некоторыми примерами ее применения. В следующей главе вы узнаете о других объектно-ориентированных возможностях РНР.
*/

echo "<br><br>";
$product2 = new CDProduct4("Пропавший без вести", "Группа", "ДДТ", 10.99, 60.33);
$discount = $product2->setDiscount(3);
print "Исполнитель: {$product2->getSummaryLine()}, Цена: {$product2->getPrice()}";

// Результат: Исполнитель: Пропавший без вести (ДДТ, Группа ): Время звучания -60.33, Цена: 7.99

/*
Глава 4. Расширенные средства

В предыдущей главе вы уже познакомились с уточнением типов аргументов методов класса и управлением доступом к свойствам и методам. Все это позволяет довольно гибко управлять интерфейсом класса. В данной главе мы подробнее изучим более сложные объектно-ориентированные возможности РНР.

В этой главе рассматриваются следующие темы:
• Статические методы и свойства: доступ к данным и функциям с помощью классов, а не объектов.
• Постоянные свойства неизменяемая часть класса, или константы.
• Абстрактные классы и интерфейсы: отделение проекта от реализации.
• Трейты: совместное использование реализации разными классами.
• Позднее статическое связывание: новая возможность в РНР 5.3.
• Обработка ошибок: знакомство с исключениями.
• Завершенные классы и методы: ограниченное наследование.
• Методы-перехватчики: автоматическая передача полномочий.
• Методы-деструкторы: освобождение ресурсов после использования объекта.
• Клонирование объектов: создание копий объектов.
• Преобразование объектов в строки: создание резюмирующего метода.
• Функции обратного вызова: добавление функциональных возможностей компонентам с помощью анонимных функций.

Статические методы и свойства
Во всех примерах предыдущей главы мы работали с объектами. Я охарактеризовал классы как шаблоны, с помощью которых создаются объекты, а объекты - как активные компоненты, методы которых мы вызываем и к свойствам которых получаем
доступ. Отсюда следовал вывод, что в объектно-ориентированном программировании реальная работа выполняется с помощью экземпляров классов. А классы в конечном счете - это просто шаблоны для создания объектов.

Но на самом деле не все так просто. Мы можем получать доступ и к методам, и к свойствам в контексте класса, а не объекта. Такие методы и свойства являются "статическими" и должны быть объявлены с помощью ключевого слова static.
*/

class StaticExample {
	static public $aNum = 0;

	static public function sayHello() {
		print "Hello";
	}
}

/*
На заметку. Ключевое слово static появилось в РНР 5. Его нельзя использовать в сценариях РНР 4.

Статические методы - это функции, используемые в контексте класса. Они сами не могут получать доступ ни к каким обычным свойствам класса, потому что такие свойства принадлежат объектам. Однако из статических методов можно обращаться к статическим свойствам. И если вы измените статическое свойство, то все экземпляры этого класса смогут получать доступ к новому значению.
Поскольку доступ к статическому элементу осуществляется через класс, а не экземпляр объекта, вам не нужна переменная, которая ссылается на объект. Вместо этого используется имя класса, после которого указывается два двоеточия "::".
*/

echo "<br><br>";

print StaticExample::$aNum;

echo "<br>";

StaticExample::sayHello();

/*
С этим синтаксисом вы познакомились в предыдущей главе. Мы использовали конструкцию "::" в сочетании с ключевым словом parent, чтобы получить доступ к переопределенному методу родительского класса. Однако теперь мы будем обращаться
к классу, а не к данным, содержащимся в объекте.

В коде класса можно использовать ключевое слово parent, чтобы получить доступ к суперклассу, не используя имя класса. 

Чтобы получить доступ к статическому методу или свойству из того же самого класса (а не из дочернего класса), мы будем использовать ключевое слово self.

Ключевое слово self используется для обращения к текущему классу, точно так же, как псевдопеременная $this - к текущему объекту. Поэтому из-за пределов класса StaticExample мы должны обращаться к свойству $aNum с помощью имени его класса.
*/
StaticExample::$aNum;

/*
А внутри класса StaticExample можно использовать ключевое слово self.
*/

class StaticExample2 {
	static public $aNum = 0;

	static public function sayHello() {
		self::$aNum++;
		print "Hello! (" . self::$aNum . ") ";
	}
}

/*
На заметку. 

Вызов метода с помощью ключевого слова parent - это единственный случай, когда следует использовать статическую ссылку на нестатический метод.
Кроме случаев обращения к переопределенному методу родительского класса, конструкция "::" должна всегда использоваться только для доступа к статическим методам или свойствам.
Однако в документации часто можно увидеть использование конструкции "::" для ссылок на методы или свойства. Это не означает, что рассматриваемый элемент - обязательно статический; это всего лишь значит, что он принадлежит к указанному классу. Например, ссылку на метод write() класса ShopProductWriter можно записать так: ShopProductWriter::write(), несмотря на то что метод write() не является статическим. Мы будем использовать данный синтаксис в книге там, где это уместно.
*/

StaticExample::sayHello();

/*
По определению к статическим методам и свойствам происходит обращение в контексте класса, а не объекта. По этой причине статические свойства и методы часто называют переменными и свойствами класса. Как следствие привязки к классу внутри статического метода нельзя использовать псевдопеременную $this для доступа к статическим элементам класса.

А зачем вообще нужны статические методы или свойства? Статические элементы имеют ряд полезных характеристик. Во-первых, они доступны из любой точки сценария (при условии, что у вас есть доступ к классу). Это означает, что вы можете вызывать функции, не передавая экземпляр класса от одного объекта другому или, что еще хуже, сохраняя экземпляр объекта в глобальной переменной. Во-вторых, статическое свойство доступно каждому экземпляру объекта этого класса. Поэтому можно определить значения, которые должны быть доступны всем объектам данного типа. И наконец, в-третьих, сам факт, что не нужно иметь экземпляр класса для доступа к его статическому свойству или методу, позволит избежать создания экземпляров объектов исключительно ради вызова простой функции.

Чтобы продемонстрировать это, давайте создадим статический метод для класса ShopProduct, который будет автоматически создавать экземпляры объектов ShopProduct на основе информации, хранящейся в базе данных. С помощью SQLite
определим таблицу products следующим образом.

CREATE TABLE products (id int AUTO_INCREMENT PRIMARY KEY, type varchar(20), firstname varchar(20), mainname varchar(20), title varchar(20), price float, numpages int, playlength int, discount int)

Теперь создадим метод getinstance(), которому передаются идентификатор строки и объект типа PDO. Они будут использоваться для извлечения строки из таблицы базы данных, на основании которой затем формируется объект типа ShopProduct, возвращаемый в вызывающую программу. Мы можем добавить эти методы к классу ShopProduct, который был создан в предыдущей главе. Как вы, наверное, знаете, РDО расшифровывается как РНР Data ОЬjесt (объекты данных РНР). Класс PDO обеспечивает универсальный интерфейс для различных приложений баз данных.

*/

class ShopProduct9 {
	private $title;
	private $producerMainName;
	private $producerFirstName;
	protected $price;
	private $discount = 0;
	private $id = 0;

	public function __construct($title, $firstName, $mainName, $price) {
		$this->title             = $title;
		$this->producerFirstName = $firstName;
		$this->producerMainName  = $mainName;
		$this->price             = $price;
	}

	public static function setId($id) {
		$this->id = $id;
	}

	public static function getInstance($id, PDO $pdo) {
		$stmt = $pdo->prepare("select * from products where id=?");
		$result = $stmt->execute(array($id));

		$row = $stmt->fetch();

		if(empty($row)) {return null;}

		if($row['type'] === "book") {
			$product = new BookProduct4 (
				$row['title'],
				$row['firstname'],
				$row['mainname'],
				$row['price'],
				$row['numpages']
				);
		}
		else if($row['type'] === "cd") {
			$product = new CDProduct4 (
				$row['title'],
				$row['firstname'],
				$row['mainname'],
				$row['price'],
				$row['playlength']
				);
		}
		else {
			$product = new ShopProduct8 (
				$row['title'],
				$row['firstname'],
				$row['mainname'],
				$row['price']
				);
			}

		$product->setId($row['id']);
		$product->setDiscount($row['discount']);
		return $product;
	}

	public function getProducerFirstName() {
		return $this->producerFirstName;
	}

	public function getProducerMainName() {
		return $this->producerMainName;
	}

	public function setDiscount($num) {
		$this->discount = $num;
	}

	public function getDiscount() {
		return $this->discount;
	}

	public function getTitle() {
		return $this->title;
	}

	public function getPrice() {
		return ($this->price - $this->discount);
	}

	public function getProducer() {
		return $this->producerFirstName . " " . $this->producerMainName;
	}

	public function getSummaryLine() {
		$base  = "{$this->title} ({$this->producerMainName}, ";
		$base .= "{$this->producerFirstName} )";
		return $base;
	}
}

/*
Как видите, метод getinstance() возвращает объект типа ShopProduct, причем он достаточно "умен" для того, чтобы на основании значения поля type создать объект с нужными характеристиками. Я специально опустил код обработки ошибок,
чтобы пример был по возможности лаконичным. Например, в реально работающей версии этого кода нам нельзя быть слишком доверчивыми и предполагать, что переданный РDО-объект был корректно проинициализирован и подключен к требуемой базе данных. На самом деле нам, вероятно, следует заключить РDОобъект в класс-оболочку, который гарантирует такое поведение. Дополнительную информацию об объектно-ориентированном программировании и базах данных вы найдете в главе 13, "Шаблоны баз данных".
Метод getinstance() более полезен в контексте класса, чем в контексте объекта. Он позволяет легко преобразовать данные, находящиеся в базе данных, в объект, причем для этого нам не нужно иметь отдельный экземпляр объекта типа ShopProduct.
В этом методе не используются никакие методы или свойства, требующие отдельного экземпляра объекта, поэтому нет никакой причины, чтобы не объявить его статическим. Тогда, имея корректный РDО-объект, мы можем вызвать данный метод из любого места приложения.


$dsn = "sqlite://home/bob/projects/products.db";
$pdo = new PDO($dsn, null, null);
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXEPTION);
$obj = ShopProduct::getInstance(1, $pdo);


Подобные методы работают, как "фабрики", поскольку они берут "сырые" материалы (например, данные, полученные из строки базы данных или файла конфиrурации) и используют их для создания объектов. Термин фабрика относится к коду, предназначенному для создания экземпляров объектов. С примерами подобных "фабрик" мы еще встретимся в последующих главах. Разумеется на основе рассмотренного выше примера мы в какой-то степени показали далеко не все проблемы. И хотя я сделал метод ShopProduct::getInstance() доступным из любой части программы без необходимости создавать экземпляр объекта ShopProduct, я также потребовал, чтобы объект PDO был передан из клиентского кода. Откуда мы должны его взять? В объектно-ориентированном программировании существует еще ряд подобных широко распространенных проблем, например где взять набор ключевых объектов программы и их значений. Различные аспекты создания объектов будут рассмотрены в главе 9, "Генерация объектов".


Постоянные свойства
Некоторые свойства объектов не должны изменяться. Например, такие элементы, как коды ошибок или коды состояния программы, задаются обычно вручную в классах. Хотя они должны быть общедоступными и статическими, клиентский код не должен иметь возможности их изменять.

В РНР 5 можно определять постоянные свойства внутри класса. Как и глобальные константы, константы класса нельзя изменять после того, как они были определены. Постоянное свойство объявляют с помощью ключевого слова const. В отличие от обычных свойств, перед именем постоянного свойства не ставится знак доллара. По принятому соглашению для них часто выбираются имена, состоящие только из прописных букв, как показано в следующем примере.

class ShopProduct {
	const AVAILABLE = 0;
	const OUT_OF_STOK = 1;
	...


Постоянные свойства моrут содержать только значения, относящиеся к элементарному типу. Константе нельзя присвоить объект. Как и к статическим свойствам, доступ к постоянным свойствам осуществляется через класс, а не через экземпляр объекта. Поскольку константа определяется без знака доллара, при обращении к ней также не требуется использовать никакой символ впереди.

print ShopProduct::AVAILABLE;

Попытка присвоить константе значение после того, как она была объявлена, приведет к ошибке на этапе синтаксического анализа.
Константы следует использовать, когда свойство должно быть доступным для всех экземпляров класса и когда значение свойства должно быть фиксированным и неизменным.


Абстрактные классы

Введение абстрактных классов стало одним из главных изменений в РНР 5. А включение этой функции в список новых возможностей стало еще одним подтверждением растущей приверженности РНР объектно-ориентированному проектированию. Экземпляр абстрактного класса нельзя создать. Вместо этого в нем определяется (и, возможно, частично реализуется) интерфейс для любого класса, который может его расширить.
Абстрактный класс определяется с помощью ключевого слова abstract. Давайте переопределим класс ShopProductWriter, который мы создали в предыдущей главе, в виде абстрактного класса.
*/

abstract class ShopProductWriter4 {
	protected $products = array();

	public function addProduct(ShopProduct $shopProduct) {
		$this->products[] = $shopProduct;
	}
}


/*
В абстрактном классе вы можете создавать методы и свойства, как обычно, но любая попытка создать его экземпляр приведет к ошибке. Например, в результате выполнения кода:


$writer = new ShopProductWriter4();

будет выведено:  Cannot instantiate abstract class ShopProductWriter4


В большинстве случаев абстрактный класс будет содержать по меньшей мере один абстрактный метод. Как и класс, он описывается с помощью ключевого слова abstract. Абстрактный метод не может иметь реализацию в абстрактном классе. Он объявляется, как обычный метод, но объявление заканчивается точкой с запятой, а не телом метода. Давайте добавим абстрактный метод write() к классу ShopProductWriter.
*/

abstract class ShopProductWriter5 {
	protected $products = array();

	public function addProduct(ShopProduct $shopProduct) {
		$this->products[] = $shopProduct;
	}

	abstract public function write();
}

/*
Создавая абстрактный метод, вы гарантируете, что его реализация будет доступной во всех конкретных дочерних классах, но детали этой реализации остаются неопределенными. Если бы мы, как показано ниже, создали класс, производный от ShopProductWriter, в котором метод write() не был бы реализован, то столкнулись бы со следующей ошибкой.
*/	

// class ErroredWriter extends ShopProductWriter5 {};

/*
Class ErroredWriter contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (ShopProductWriter5::write)

Итак, в любом классе, который расширяет абстрактный класс, должны быть реализованы все абстрактные методы либо сам класс должен быть объявлен абстрактным. При этом в расширяющем классе должны быть не просто реализованы все абстрактные методы, но должна быть воспроизведена сигнатура этих методов. Это означает, что уровень доступа в реализующем методе не может быть более строгим, чем в абстрактном методе. Реализующему методу также должно передаваться такое же количество аргументов, как и абстрактному методу, а также в нем должны воспроизводиться все уточнения типов класса.
Ниже приведены две реализации класса ShopProductWriter.

*/

class XmlProductWriter extends ShopProductWriter5 {

	public function write() {
		$writer = new XMLWriter();
		$writer->openMemory();
		$writer->startDocument('1.0', 'UTF-8');
		$writer->startElement("products");

		foreach ($this->products as $shopProduct) {
			$writer->startElement("product");
			$writer->writeAttribute("title", $shopProduct->getTitle());
				$writer->startElement("summary");
				$writer->text($shopProduct->getSummaryLine());
				$writer->endElement();  //summary
			$writer->endElement();  //product
		}
		$writer->endElement();  //products
		$writer->endDocument();
		print $writer->flush();
	}
}


class TextProductWriter extends ShopProductWriter5 {

	public function write() {
		$str = "ТОВАРЫ: ";
		foreach ($this->products as $shopProduct) {
			$str .= $shopProduct->getSummaryLine() . "";
		}
		print $str;
	}
}


/*
Я создал два класса, каждый с собственной реализацией метода write(). Первый выводит данные о товаре в формате ХМL, а второй - в текстовом виде. Теперь методу, которому требуется передать объект типа ShopProductWriter, не нужно точно
знать, какой из этих двух классов он получает, поскольку ему достоверно известно, что в обоих классах реализован метод write(). Обратите внимание на то, что мы не проверяем тип переменной $products, прежде чем использовать ее как массив.
Причина в том, что это свойство инициализируется как пустой массив в классе ShopProductWriter.

В РНР 4 работу абстрактных классов моделировали с помощью методов, которые выводили предупреждающие сообщения или даже содержали операторы die(). Это заставляло программиста реализовывать абстрактные методы в производном классе, поскольку в противном случае сценарий переставал работать.

class AbstractClass {
	funtion abstractFunction() {
		die("AbstractClass::abstractFunction(	) - абстрактная функция! ");
	}
}

Проблема в таком подходе состоит в том, что абстрактная природа базового класса проверяется только в случае вызова абстрактного метода. В РНР 5 абстрактные классы проверяются еще на этапе синтаксического анализа, что намного безопаснее.


Интерфейсы

Как известно, в абстрактном классе допускается реализация некоторых методов, не объявленных абстрактными. В отличие от них, интерфейсы - это чистой воды шаблоны. С помощью интерфейса можно только определить функциональность, но не реализовать ее. Для объявления интерфейса используется ключевое слово interface. В интерфейсе могут находиться только объявления методов, но не тела этих методов. Давайте определим интерфейс.
*/

interface Chargeable {
	public function getPrice();
}

/*

Как видите, интерфейс очень похож на класс. В любом классе, поддерживающем этот интерфейс, нужно реализовать все методы, определенные в интерфейсе; в противном случае класс должен быть объявлен как абстрактный. При реализации интерфейса в классе имя интерфейса указывается в объявлении этого класса после ключевого слова implements. После этого процесс реализации
интерфейса станет точно таким же, как расширение абстрактного класса, который содержит только абстрактные методы. Давайте сделаем так, чтобы в классе ShopProduct был реализован интерфейс Chargeable.

class ShopProduct implements Chargeable {
	// ...
	public function getPrice() {
		return ($this->price - $this->discount);
	}

	// ...

В классе ShopProduct уже есть метод getPrice(), что же может быть полезного в реализации интерфейса Chargeable? И снова ответ связан с типами. Дело в том, что реализующий класс принимает тип класса и интерфейса, который он расширяет. Это означает, что класс CDProduct относится к следующим типам.

CDProduct
ShopProduct
Chargeable

Эту особенность можно использовать в клиентском коде. Как известно, тип объекта определяет его функциональные возможности. Поэтому метод 

public function CDInfo(CDProduct $prod) {
	//...
}

знает, что у объекта $prod есть метод getPlayLength(), а также все остальные методы, определенные в классе ShopProduct и интерфейсе Chargeable. Если тот же самый объект CDProduct передается методу

public function addProduct(ShopProduct $prod) {
	//...
}

то известно, что объект $prod поддерживает все методы, определенные в классе ShopProduct. Однако без дальнейшей проверки данный метод ничего не будет знать о методе getPlayLength().
И снова, если передать тот же объект CDProduct методу

public function addChargeableItem(Chargeable $item) {
	//...
}

данному методу ничего не будет известно обо всех методах, определенных в классах ShopProduct или CDProduct. При этом интерпретатор только проверит, содержится ли в аргументе $item метод getPrice(). Поскольку интерфейс можно реализовать в любом классе (на самом деле в классе можно реализовать любое количество интерфейсов), с помощью интерфейсов можно
эффективно объединить типы данных, не связанных никакими другими отношениями. В результате мы можем определить совершенно новый класс, в котором реализуется интерфейс Chargeable.

class Shipping implements Chargeable {
	public function getPrice() {
		//...
	}
}


Затем объект типа Shipping мы можем передать методу addChargeableItem(), точно так же, как мы передавали ему объект типа ShopProduct.
Для клиента, работающего с объектом типа ChargeaЬle, очень важно то, что он может вызвать метод getPrice(). Любые другие имеющиеся методы связаны с другими типами - через собственный класс объекта, суперкласс или другой интерфейс.
Но они не имеют никакого отношения к нашему клиенту.
В классе можно как расширить суперкласс, так и реализовать любое количество интерфейсов. При этом ключевое слово extends должно предшествовать ключевому слову implements, как показано ниже.

class Consultancy extends TimedService implements Bookable, Chargeable {
	//...
}


Обратите внимание на то, что в классе Consultancy реализуется более одного интерфейса. После ключевого слова implements можно перечислить через запятую несколько интерфейсов.

В РНР поддерживается только наследование от одного родителя (так называемое одиночное наследование), поэтому после ключевого слова extends можно указать только одно имя базового класса.


Трейты

В отличие от языка С++, в РНР, как и в языке Java, не поддерживается множественное наследование. Однако эту проблему можно частично решить с помощью интерфейсов, как было показано в предыдущем разделе. Другими словами, для каждого класса в РНР может существовать только один родительский класс. Тем не менее в каждом классе можно реализовать произвольное количество интерфейсов. При этом данный класс будет соответствовать типам всех тех интерфейсов, которые в нем реализованы. 

Как видите. с помощью интерфейсов создаются новые типы объектов без их реализации. Но что делать, если вам нужно реализовать ряд общих методов для всей иерархии наследования классов? Для этой цели в РНР 5.4 было введено понятие
трейтов.

По сути, трейты напоминают классы, для которых нельзя создать экземпляр объекта, но которые можно включить в другие классы. Поэтому любое свойство (или метод), определенное в трейте, становится частью того класса, в который этот трейт включен. При этом трейт изменяет структуру этого класса, но не меняет его тип. Можно считать трейты своего рода оператором include, действие которого распространяется только на конкретный класс.

Давайте рассмотрим на примерах, насколько могут быть полезны трейты.

Проблемы, которые можно решить с помощью трейтов 

Ниже приведена версия класса ShopPoduct, в который был включен метод calculateTax().

*/

class ShopProduct10 {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100)  * $price);
	}
}

echo "<br>";
$p = new ShopProduct10();
print $p->calculateTax(100) . "";


/*
Методу calculateTax() в качестве параметра $price передается цена товара, а он вычисляет налог с продаж на основе значения ставки, сохраненной во внутреннем свойстве $taxrate.
Разумеется , доступ к методу calculateTax() будет у всех подклассов данного класса. Но что нам делать, если речь заходит о совершенно другой иерархии классов?

Представьте себе класс UtilityService, который унаследован от другого класса Service. И если для класса UtilityService понадобится определить величину налога по точно такой же формуле, то нам ничего не остается другого, как просто целиком
скопировать тело метода calculateTax(), как показано ниже.
*/

abstract class Service {
	//Базовый класс для службы сервиса
}

class UtilityService extends Service {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100)  * $price);
	}
}

echo "<br>";
$p = new UtilityService();
print $p->calculateTax(100) . "";


/*
Определение и использование трейтов

Одной из целей объектно-ориентированного проектирования, которая красной нитью проходит через всю эту книгу, является устранение проблемы дублирования кода. Как будет показано в главе 11, "Выполнение задач и представление результатов",
одним из возможных путей решения этой проблемы является вынесение общих фрагментов кода в отдельные повторно используемые стратегические классы (strategy class). Трейты также позволяют решить данную проблему, хотя, возможно, и менее элегантно, но, вне всякого сомнения, эффективно.
В приведенном ниже примере я объявил простой трейт, содержащий метод calculateTax(), а затем включил его сразу в оба класса: ShopProduct и UtilityService.

*/

trait PriceUtilities {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100)  * $price);
	}

	// Другие общие методы
}

class ShopProduct11 {
	use PriceUtilities;
}

abstract class Service2 {
	//Базовый класс для службы сервиса
}

class UtilityService2 {
	use PriceUtilities;
}

echo "<br>";
$p = new ShopProduct11();
print $p->calculateTax(100) . "";

echo "<br>";
$u = new UtilityService2();
print $u->calculateTax(100) . "";


/*
Как видите, трейт PriceUtilities объявляется с помощью ключевого слова trait. Тело трейта сильно напоминает тело обычного класса. В нем в фигурных скобках просто указывается набор методов (или, как вы увидите ниже, свойств). После объявления
трейта PriceUtilities я могу его использовать при создании собственных классов. Для этого используется ключевое слово use, после которого указывает имя трейта. В результате, объявив и реализовав в одном месте метод calculateTax(), я могу его использовать в обоих классах: и в ShopProduct , и в UtilityService.


Использование нескольких трейтов
В класс можно включить несколько трейтов. Для этого их нужно перечислить через запятую после ключевого слова use. В приведенном ниже примере я определил и реализовал новый трейт IdentityTrait, а затем использовал его в своем классе
наряду с трейтом PriceUtilities.
*/

trait IdentityTrait {
	public function generateId() {
		return uniqid();
	}
}

trait PriceUtilities2 {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100)  * $price);
	}

	// Другие общие методы
}

class ShopProduct12 {
	use PriceUtilities2, IdentityTrait;
}

echo "<br>";
$p = new ShopProduct12();
print $p->calculateTax(100) . "";
print $p->generateId() . "";


/*
Перечислив оба трейта, PriceUtilities и IdentityTrait, после ключевого слова use, я сделал доступными методы calculateTax() и generateId() для класса ShopProduct. Это означает, что эти методы становятся членами класса ShopProduct.

На заметку. В трейте IdentityTrait реализован метод generateId(). По сути, уникальные значения идентификаторов объектов часто извлекаются из базы данных, но в целях тестирования иногда требуется использовать их локальные реализации. Более подробно об объектах, базах данных и уникальных идентификаторах мы поговорим в главе 13, "Шаблоны баз данных", где описан шаблон IdentityМар. О процессе тестирования и имитации функционала объектов (mocking) речь пойдет в главе 18, "Тестирование с помощью PHPUпit".


Совместное использование трейтов и интерфейсов

Несмотря на то что полезность применения трейтов не вызывает особых сомнений, они не позволяют изменить тип класса, в который были включены. Поэтому, если трейт IdentityTrait используется сразу в нескольких классах, у вас не будет общего типа, который можно было бы указать в уточнениях для сигнатур методов. К счастью, трейты можно успешно использовать вместе с интерфейсами. Мы можем определить интерфейс с сигнатурой метода generateid(), а затем указать, что в классе ShopProduct реализуются методы этого интерфейса.
*/

interface IdentityObject {
	public function generateId();
}

trait IdentityTrait2 {
	public function generateId() {
		return uniqid();
	}
}

trait PriceUtilities3 {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100)  * $price);
	}

	// Другие общие методы
}

class ShopProduct13 implements IdentityObject {
	use PriceUtilities2, IdentityTrait;
}

/*
Здесь, как и в предыдущем примере, в классе ShopProduct используется трейт IdentityTrait. Однако импортируемый с его помощью метод generateId() теперь также удовлетворяет требованиям интерфейса IdentityObject. А это означает, что
мы можем передавать объекты ShopProduct тем методам и функциям, в описании аргументов которых используются уточнения типа объекта IdentityObject, как показано ниже.
*/

function storeIdentityObject(IdentityObject $idobj) {
	// Работа с объектом типа IdentityObject
}


echo "<br>";
$p = new ShopProduct13();
storeIdentityObject($p);


/*
Устранение конфликтов имен с помощью ключевого слова insteadof

Возможность комбинирования трейтов является просто замечательной! Однако рано или поздно вы можете столкнуться с конфликтом имен. Например, что произойдет, если в обоих включаемых трейтах будет реализован метод calculateTax(), как показано ниже?


trait TaxTools {
	function calculateTax($price) {
		return 222;
	}
}

trait PriceUtilities4 {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100) * $price);
	}

	//Другие методы
}

abstract class Service4 {
	// Базовый класс для службы сервиса
}

class UtilityService4 extends Service {
	use PriceUtilities, TaxTools;
}


echo "<br>";
$u = new UtilityService();
print $u->calculateTax(100) . "";


Поскольку в один класс мы включили два трейта, содержащие методы calculateTax(), интерпретатор РНР не сможет продолжить работу, так как он не знает, какой из методов нужно использовать. В результате выводится сообщение о
неустранимой ошибке, как показано ниже.

Fatal error: Trait method calculateTax has not been applied, because there are collisions with other trait methods on UtilityService4 in

Для устранения этой проблемы используется ключевое слово insteadof, как показано ниже.
*/

trait TaxTools2 {
	function calculateTax($price) {
		return 222;
	}
}

trait PriceUtilities4 {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100) * $price);
	}

	//Другие методы
}

abstract class Service5 {
	// Базовый класс для службы сервиса
}

class UtilityService5 extends Service5 {
	use PriceUtilities4, TaxTools2 {
		TaxTools2::calculateTax insteadof PriceUtilities4;
	}
}

echo "<br>";
$u = new UtilityService5();
print $u->calculateTax(100) . "";

/*
Для того чтобы можно было применять директивы оператора use, нам нужно добавить к нему тело, которое помещается в фигурные скобки. Внутри этого блока используется конструкция с ключевым словом insteadof (вместо). Слева от него указывается полностью определенное имя метода, состоящее из имени трейта и имени метода. Они разделяются двумя двоеточиями, играющими в данном случае роль оператора определения зоны видимости. В правой части конструкции insteadof указывается имя трейта, метод которого с аналогичным именем должен быть заменен. Таким образом, запись

TaxTools2::calculateTax insteadof PriceUtilities4;

означает, что следует использовать метод calculateTax() трейта TaxTools в место одноименного метода трейта PriceUtilities.
Поэтому при запуске приведенного выше кода будет выведено число 222, которое я ввел в код метода TaxTools::calculateTax().


Псевдонимы для переопределенных методов трейта

Выше мы уже убедились в том, что с помощью ключевого слова insteadof можно устранить конфликт имен методов, принадлежащих разным трейтам. Однако что делать, если вдруг понадобится вызвать в коде переопределенный метод трейта? Для этого используется ключевое слово as, которое позволяет назначить этому методу псевдоним. Как и в конструкции с ключевым словом insteadof, при использовании as нужно слева от него указать полностью определенное имя метода, а справа - псевдоним имени метода. В приведенном ниже примере метод calculateTax() трейта PriceUtilities был восстановлен под новым именем basicTax().

*/

trait TaxTools3 {
	function calculateTax($price) {
		return 222;
	}
}

trait PriceUtilities5 {
	private $taxrate = 17;

	function calculateTax($price) {
		return (($this->taxrate/100) * $price);
	}

	//Другие методы
}

abstract class Service6 {
	// Базовый класс для службы сервиса
}

class UtilityService6 extends Service6 {
	use PriceUtilities5, TaxTools3 {
		TaxTools3::calculateTax insteadof PriceUtilities5;
		PriceUtilities5::calculateTax as basicTax;

	}
}

echo "<br>";
$u = new UtilityService6();
print $u->calculateTax(100) . "";
echo "<br>";
print $u->basicTax(100) . "";


/*
Как видите, метод трейта PriceUtilities::calculateTax() стал частью класса UtilityService под именем basicTax().

На заметку. При возникновении конфликта имен между методами разных трейтов недостаточно просто назначить одному из методов псевдоним в блоке use. Сначала вы должны решить, какой из методов должен быть замещен, и указать это с помощью ключевого слова insteadof. Затем замещенному методу можно назначить псевдоним с помощью ключевого слова as и восстановить его в классе под новым именем.

Кстати, здесь уместно отметить, что псевдонимы имен методов можно использовать даже тогда, когда нет никакого конфликта имен. Так, например, с помощью метода трейта вы можете реализовать абстрактный метод, сигнатура которого была объявлена в родительском классе или интерфейсе.


Использование статических методов в трейте

В большинстве примеров, которые мы рассматривали до сих пор, использовались статические методы, поскольку для их вызова не требуются экземпляры класса. Поэтому нам ничто не мешает поместить статический метод в трейт. В приведенном ниже примере я изменил описание свойства PriceUtilities::$taxrate и метода PriceUtilities::calculateTax() так, чтобы они стали статическими.
*/

trait PriceUtilities6 {
	private static $taxrate = 17;

	static function calculateTax($price) {
		return ((self::$taxrate/100) * $price);
	}

	//Другие методы

}

abstract class Service7 {
	// Базовый класс для службы сервиса
}

class UtilityService7 extends Service7 {
	use PriceUtilities6;
}

echo "<br>";
$u = new UtilityService7();
print $u::calculateTax(100) . "";


/*
Доступ к свойствам базового класса

После рассмотрения приведенных выше примеров у вас могло сложиться впечатление, что для работы с трейтами подходят только статические методы. И даже те методы трейта, которые не описаны как статические, являются по своей природе статическими. ведь так? Ну что же, вас ввели в заблуждение - к свойствам и методам базового класса также можно получить доступ.

*/

trait PriceUtilities7 {
	function calculateTax($price) {
		//Хорош ли такой подход?
		return (($this->taxrate/100) * $price);
	}

	//Другие методы

}

abstract class Service8 {
	// Базовый класс для службы сервиса
}

class UtilityService8 extends Service8 {
	public $taxrate = 17;
	use PriceUtilities7;
}

echo "<br>";
$u = new UtilityService8();
print $u->calculateTax(100) . "";

/*
Здесь я усовершенствовал трейт PriceUtilities так, чтобы из него можно было обращаться к свойству базового класса. И если вам кажется, что такой подход плох, то вы правы. Скажу больше - он вызывающе плох! Несмотря на то что обращение из трейтов к данным, расположенным в базовом классе, является обычной практикой, у нас не было весомых причин объявлять свойство $taxrate в классе UtilityService. Здесь не стоит забывать, что трейты могут использоваться во многих совершенно разных классах. И кто может дать гарантию (или даже обещание!), что в каждом базовом классе будет объявлено свойство $taxrate?
С другой стороны, будет просто замечательно, если вам удастся заключить договор с пользователем, в котором в частности говорится: "При использовании данного трейта вы обязаны предоставить в его распоряжение определенные ресурсы". По сути, здесь нам удалось достичь точно такого же эффекта. Дело в том, что в трейтах поддерживаются абстрактные методы.


Определение абстрактных методов в трейтах

В трейтах можно объявлять абстрактные методы точно так же, как и в обычных классах. При использовании такого трейта в классе в нем должны быть реализованы все объявленные в трейте абстрактные методы. Имея это в виду, я могу переписать предыдущий пример так, чтобы трейт заставлял использующий его класс предоставлять информацию о ставке налога.

*/

trait PriceUtilities8 {
	function calculateTax($price) {
		//Гораздо лучший подход, поскольку нам точно известно, что метод getTaxRate() будет реализован
 		return (($this->getTaxRate()/100) * $price);
	}

	abstract function getTaxRate();

	//Другие методы

}

abstract class Service9 {
	// Базовый класс для службы сервиса
}

class UtilityService9 extends Service9 {
	use PriceUtilities8;
	function getTaxRate() {
		return 17;
	}
}

echo "<br>";
$u = new UtilityService9();
print $u->calculateTax(100) . "";


/*
Объявив абстрактный метод getTaxRate() в трейте PriceUtilities, я вынудил программиста обеспечить его реализацию в классе UtilityService. Разумеется, поскольку в РНР не накладывается каких-либо жестких ограничений на тип возвращаемого значения, нельзя быть точно уверенным в том, что в методе UtilityService::calculateTax() мы получим от метода getTaxRate() корректное
значение. Этот недостаток можно преодолеть, поместив в код операторы, выполняющие все возможные виды проверок, но тем самым мы не достигнем поставленной цели. Здесь, вероятнее всего, будет вполне достаточно указать программисту клиентского кода, что при реализации затребованных нами методов нужно возвратить значение заданного типа.


Изменение прав доступа к методам трейта

Разумеется, ничто не может вам помешать объявить методы трейта открытыми (public), защищенными (protected) или закрытыми (private). Тем не менее вы можете также изменить эти атрибуты доступа к методам прямо внутри класса, в котором используется трейт. Выше было показано, как с помощью ключевого слова as можно назначить методу псевдоним. Если справа от этого ключевого слова указать новый модификатор доступа, то вместо назначения методу псевдонима будет изменен его атрибут доступа.
Давайте в качестве примера представим, что вы хотите использовать метод calculateTax() только внутри класса UtilityService и вам не нужно, чтобы этот метод можно было вызвать из клиентского кода. Внесите изменения в оператор use, как показано ниже.
*/

trait PriceUtilities9 {
	function calculateTax($price) {
 		return (($this->getTaxRate()/100) * $price);
	}

	abstract function getTaxRate();

	//Другие методы

}

abstract class Service10 {
	// Базовый класс для службы сервиса
}

class UtilityService10 extends Service10 {
	use PriceUtilities9 {
		PriceUtilities9::calculateTax as private;
	}
	private $price;
	function __comstruct($price) {
		$this->price = $price;
	}
	
	function getTaxRate() {
		return 17;
	}

	function getFinalPrice() {
		return ($this->price + $this->calculateTax($this->price));
	}
}

echo "<br>";
$u = new UtilityService10(100);
print $u->getFinalPrice() . "";

/*
Для того чтобы закрыть доступ к методу calculateTax() извне класса UtilityService, после ключевого слова as в операторе use был указан модификатор private. В результате доступ к этому методу стал возможен только из метода getFinalРriсе().
Теперь при попытке обращения к методу calculateTax() извне класса, например так:


echo "<br>";
$u = new UtilityService10(100);
print $u->calculateTax() . "";

выводится сообщение об ошибке:
Call to private method UtilityService10::calculateTax() from context '' in 


Позднее статическое связывание: ключевое слово static

После того как мы рассмотрели абстрактные классы, трейты и интерфейсы, самое время снова ненадолго обратиться к статическим методам. Вы уже знаете, что статический метод можно использовать в качестве фабрики, создающей экземпляры объектов того класса, в котором содержится этот метод. Если вы такой же ленивый программист, как и я, то вас должны раздражать повторы кода наподобие приведенных ниже.
*/
abstract class DomainObject {}

class User extends DomainObject {
	public static function create() {
		return new User();
	}
}

class Document extends DomainObject {
	public static function create() {
		return new Document();
	}
}

/*
Сначала я создал суперкласс под именем DomainObject. Само собой разумеется, что в реальном проекте в нем будет находиться функциональность, общая для всех дочерних классов. После этого я создал два дочерних класса: User и Document. Я хотел,
чтобы в каждом из моих конкретных классов находился метод create().

На заметку. Почему для создания конкретного объекта я воспользовался статическим методом-фабрикой, а не оператором new и конструктором объекта? В главе 13, "Шаблоны баз данных", я описал шаблон ldentity Мар. Компонент ldentity Мар создает и инициализирует новый объект только в том случае, если объект с аналогичными отличительными особенностями еще не создан. Если таковой объект существует, то возвращается просто ссылка на него. Статический метод-фабрика наподобие рассмотренного выше метода create() является отличным кандидатом для реализации подобной функциональности.

Созданный мною выше код прекрасно работает, но в нем есть досадный недостаток - дублирование. Мне совсем не нравится повторять однотипный код наподобие того, который приведен выше, для каждого создаваемого дочернего объекта, расширяющего класс DomainObject. Как насчет того, чтобы переместить метод create() в суперкласс?


abstract class DomainObject2 {
	public static function create() {
		return new self();
	}
}

class User2 extends DomainObject2 {
}

class Document2 extends DomainObject2 {
}

Document2::create();


Ну что ж, все это выглядит круто! Теперь весь общий код сосредоточен в одном месте, и, чтобы обратиться к текущему классу, я воспользовался ключевым словом self. Однако насчет ключевого слова self я сделал допущение, что оно должно так
работать. На самом деле оно не работает для классов так же, как псевдопеременная $this для объектов. С помощью ключевого слова self нельзя сослаться на вызывающий контекст. Оно используется только для разрешения ссылок на содержащий класс, в контексте которого вызывается метод. Поэтому при попытке запуска приведенного выше примера получим следующее сообщение об ошибке.

Fatal error: Cannot instantiate abstract class DomainObject2


Таким образом, ключевое слово self трансформируется в ссылку на класс DomainObject, в котором определен метод create(), а не на класс Document, для которого этот метод должен быть вызван. До появления РНР 5.3 это было серьезным ограничением языка, которое породило массу неуклюжих обходных решений. В РНР 5.3 впервые введена концепция позднего статического связывания (late static bindings). Самым заметным ее проявлением является введение нового (в данном контексте) ключевого слова static. Оно аналогично ключевому слову self, за исключением того, что относится к вызывающему, а не содержащему классу. В данном случае это означает, что в результате вызова метода Document::create() возвращается новый объект типа Document и не будет предприниматься безуспешная попытка создать объект типа DomainObject.
Итак, теперь я смогу воспользоваться всеми преимуществами наследования в статическом контексте.
*/

abstract class DomainObject3 {
	public static function create() {
		return new static();
	}
}

class User3 extends DomainObject3 {
}

class Document3 extends DomainObject3 {
}

print_r(Document3::create());

/* 

В результате будет выведено следующее: Document3 Object ()

Ключевое слово static можно использовать не только для создания объектов. Так же, как и self и parent, его можно использовать как идентификатор для вызова статических методов даже из нестатического контекста. Например, я хочу реализовать идею группировки моих классов типа DomainObject. По умолчанию все классы попадают в категорию 'default'. Но для некоторых веток иерархии наследования моих классов мне нужно это переопределить.
*/

abstract class DomainObject4 {
	private $group;

	public function __construct() {
		$this->group = static::getGroup();
	}

	public static function create() {
		return new static();
	}

	static function getGroup() {
		return "default";
	}
}

class User4 extends DomainObject4 {
}

class Document4 extends DomainObject4 {
	static function getGroup() {
		return "document";
	}
}

class SpreadSheet extends Document4 {
}

echo "<br>";
print_r(User4::create());
echo "<br>";
print_r(SpreadSheet::create());

/*
Здесь в класс DomainObject я ввел конструктор, в котором используется ключевое слово static для вызова метода getGroup(). Стандартное значение группы сосредоточено в классе DomainObject, но оно переопределяется в классе Document. Я также
создал новый класс SpreadSheet, расширяющий класс Document. Вот что получим в результате.


Все происходящее с классом User не настолько очевидно и поэтому требует объяснений. В конструкторе класса DomainObject вызывается метод getGroup(), который интерпретатор находит в текущем классе. Несмотря на это, в случае с классом
SpreadSheet поиск метода getGroup() начинается не с класса DomainObject, а с класса SpreadSheet, для которого из метода create() был вызван стандартный конструктор. Поскольку в классе SpreadSheet реализация метода getGroup() не предусмотрена,
интерпретатор вызывает аналогичный метод класса Document (т.е. идет вверх по иерархии объектов). До появления РНР 5.3 и позднего статического связывания здесь у меня возникала проблема из-за использования ключевого слова self, которое находило метод getGroup() только в классе DomainObject.



Обработка ошибок

Иногда все идет не так, как надо. Файлы где-то потерялись, объекты для связи с серверами баз данных остались не инициализированными. URL-aдpeca изменились, ХМL-файлы были повреждены, права доступа установлены неправильно, лимиты
на дисковую память превышены. Этот список можно продолжать до бесконечности. В стремлении предусмотреть любую проблему простой метод может иногда утонуть под тяжестью собственного кода обработки ошибок.

Ниже приведено определение простого класса Conf, который сохраняет, извлекает и определяет данные в ХМL-файле конфигурации.
*/

class Conf {
	private $file;
	private $xml;
	private $lastmatch;

	function __construct($file) {
		$this->file = $file;
		$this->xml = simplexml_load_file($file);
	}

	function write() {
		file_put_contents($this->file, $this->xml->asXML());
	}

	function get($str) {
		$matches = $this->xml->xpath("/conf/item[@name=\"$str\"]");
		if(count($matches)) {
			$this->lastmatch = $matches[0];
			return (string)$matches[0];
		}
		return null;
	}

	function set($key, $value) {
		if(!is_null($this->get($key))) {
			$this->lastmatch[0] = $value;
			return;
		}
		$conf = $this->xml->conf;
		$this->xml->addChild('item', $value)->addAttribute('name', $key);
	}
}

/*
В классе Conf для доступа к парам "имя-значение" используется расширение РНР SimpleXml. Ниже приведен фрагмент файла конфигурации в формате ХМL, с которым работает наш класс.


<?xml version="1.0"?>
<conf>
	<item name="user">bob</item>
	<item name="pass">newpass</item>
	<item name="host">localhost</item>
</conf>

Конструктору класса Conf передается имя файла конфигурации, которое далее передается функции simplexml_load_file(). Полученный от функции объект типа SimpleXmlElement сохраняется в свойстве $xml. В методе get() для нахождения
элемента item с заданным атрибутом name используется метод xpath объекта SimpleXmlElement. Значение найденного элемента возвращается в вызывающий код. Метод set() либо меняет значение существующего элемента, либо создает новый. И наконец метод write() сохраняет данные о новой конфигурации в исходном файле на диске.

Как и многие коды, приведенные в качестве примеров, код класса Conf крайне упрощен. В частности, в нем не предусмотрена обработка ситуаций, когда файл конфигурации не существует или в него нельзя записать данные. Этот код также слишком "оптимистичен". В нем предполагается, что ХМL-документ правильно отформатирован и содержит ожидаемые элементы.
Провести тестирование подобных ошибок достаточно просто, но мы должны решить, как нужно на них реагировать, если они возникнут. В целом у нас есть две возможности.

l . Мы можем завершить выполнение программы. Это простой, но радикальный выход. В результате наш скромный класс будет виноват в том, что из-за него потерпела неудачу вся программа. Хотя такие методы. как _ construct() и write(), удачно расположены в коде для обнаружения ошибок, у них нет информации, позволяющей решить, как обрабатывать эти ошибки.

2. Вместо обработки ошибки в классе мы можем вернуть признак ошибки в том или ином виде. Это может быть булево или целое значение, например 0 или -1. В некоторых классах можно также сформировать текстовое сообщение об ошибке или набор специальных признаков, чтобы клиентский код мог запросить больше информации в случае неудачного завершения программы.
Во многих РЕАR-пакетах сочетаются эти два подхода и возвращается объект ошибок (экземпляр класса PEAR Error). Наличие этого объекта говорит о том, что произошла ошибка, а подробная информация о ней содержится в самом объекте. Этот подход в настоящее время не рекомендуется использовать, но многие классы до сих пор не были обновлены в значительной степени из-за того, что клиентский код зачастую рассчитан на старые стандарты.

Проблема также заключается еще и в том, что возвращаемое значение может быть затерто. В РНР нет средств, заставляющих возвращать унифицированное значение. На момент написания данной книги в РНР не поддерживались уточнения типа для возвращаемого класса, поэтому ничто не может нам помешать вернуть признак ошибки вместо ожидаемого объекта или значения элементарного типа. Делая так, мы должны полагаться на то, что клиентский код будет проверять тип возвращаемого объекта после каждого вызова нашего метода, подверженного ошибкам. А это довольно рискованно. Никому нельзя доверять! Когда в вызывающий код возвращается ошибочное значение, нет никакой гарантии, что клиентский код будет "вооружен" лучше нашего метода и сможет решить, как обрабатывать ошибку. А если не сможет, то проблемы будут появляться снова и снова. В клиентском методе нужно будет определить, как реагировать на ошибочную ситуацию, и, возможно, даже реализовать другую стратегию сообщения об ошибке.


Исключения
В РНР 5 было введено понятие исключения, представляющее собой совершенно другой способ обработки ошибок. Я хочу сказать - совершенно другой для РНР. Но если у вас есть опыт работы с Java или С++, то исключения покажутся вам знакомыми и близкими. Использование исключений позволяет решить все проблемы, которые я описывал в данном разделе. Исключение - это специальный объект, который является экземпляром встроенного класса Exception (или производного от него класса). Объекты типа Exception
предназначены для хранения информации об ошибках и выдачи сообщений о них. Конструктору класса Exception передаются два необязательных аргумента: строка сообщения и код ошибки. В этом классе существуют также некоторые полезные методы для анализа ошибочной ситуации (табл. 4.1).


Таблица 4. 1 . Общедоступные методы класса Exception

Метод                         Описание

getMessage()                  Получить строку сообщения, переданную конструктору

getCode()                     Получить код ошибки (целое число), который был передан конструктору

getFile()                     Получить имя файла, в котором было сгенерировано исключение

getLine()                     Получить номер строки, в которой было сгенерировано исключение

getPrevious()                 Получить вложенный объект типа Exception

getTrace()                    Получить многомерный массив, отслеживающий вызовы метода, которые привели к исключению, 
                              в том числе имя метода, класса, файла и значение аргумента

getTraceAsString()            Получить строковую версию данных, возвращенных методом getTrace()

__toString()                  Вызывается автоматически, когда объект Exception используется в контексте строки. 
                              Возвращает строку, описывающую подробности исключения



Класс Exception крайне полезен для поиска сообщения об ошибке и информации для отладки (в этом отношении особенно полезны методы getTrace() и getTraceAsString() ). На самом деле класс Exception почти идентичен классу PEAR_Error, который мы обсуждали выше. Но в нем сохраняется меньше информации об исключениях, чем есть на самом деле.


Генерация исключений
Совместно с объектом Exception используется ключевое слово throw. Оно останавливает выполнение текущего метода и передает ответственность за обработку ошибок назад в вызывающий код. Давайте подкорректируем мeтoд _construct(), чтобы использовать оператор throw.


function __construct($file) {
	$this->file = $file;
	if(!file_exists($file)) {
		throw new Exeption("Файл '$file' не найден");
	}
	$this->xml = simplexml_load_file($file);
}

Аналогичная конструкция может использоваться и в методе write().

function write() {
	if(!is_writeable($this->file)) {
		throw new Exeption("Файл '{$this->file}' недоступен для записи.");
	}
	file_put_contents($this->file, $this->xml->asXML());
}


Теперь наши методы __construct() и write() могут тщательно проверять ошибки, связанные с доступом к файлу, по мере выполнения своей работы. Однако при этом решение о том, как реагировать на любые обнаруженные ошибки, будет приниматься
в клиентском коде.
Так как же тогда клиентский код узнает, что возникло исключение и настала пора его обрабатывать? Для этого при вызове метода, в котором может возникнуть исключение, следует использовать оператор try. Оператор try состоит из ключевого
слова try и следующих за ним фигурных скобок. За оператором try должен следовать по меньшей мере один оператор catch, в котором можно обработать любую ошибку, как показано ниже:
*/

try {
	$conf = new Conf(dirname(_FILE_) . "/conf01.xml");
	print "user: " . $conf->get('user') . "";
	print "host: " . $conf->get('host') . "";
	$conf->set("pass", "newpass");
	$conf->write();
} catch (Exeption $e) {
	die($e->__toString());
}

/*
Как видите, оператор catch внешне напоминает объявление метода. Когда генерируется исключение, управление передается оператору catch в контексте вызывающего метода, которому автоматически передается в качестве переменной-аргумента
объект типа Exception.
Теперь, если при выполнении метода возникнет исключение и вызов этого метода находится внутри оператора try, работа сценария останавливается и управление передается непосредственно оператору catch.


Создание подклассов класса Exception

Вы можете создать классы, расширяющие класс Exception, точно так же, как это делается для любого другого определенного пользователем класса. Существуют две причины, по которым возникает необходимость это сделать. Во-первых, можно расширить
функциональность класса. Во-вторых, производный класс определяет новый тип класса, который поможет при обработке ошибок.
В сущности, для одного оператора try вы можете определить столько операторов catch, сколько нужно. То, какой конкретно оператор catch будет вызван, будет зависеть от типа сгенерированного исключения и указанного уточнения типа класса в
списке аргументов. Давайте определим некоторые простые классы, расширяющие класс Exception.
*/

class XmlException extends Exception {
	private $error;

	function __construct(LibXmlError $error) {
		$shortfile = basename($error->file);
		$msg = "[{$shortfile}, строка {$error->line}, ";
		$msg .= "колонка {$error->column}] {$error->message}";
		$this->error = $error;
		parent::__construct($msg, $error->code);
	}

	function getLibXmlError() {
		return $this->error;
	}
}


class FileException extends Exception { }
class ConfException extends Exception { }


/*
Объект типа LibXmlError создается автоматически, когда средства SimpleXml обнаруживают поврежденный ХМL-файл. У него есть свойства message и code, и он напоминает класс Exception. Мы пользуемся преимуществом этого подобия и используем объект LibXmlError в классе XmlException. У классов FileException и ConfException не больше функциональных возможностей, чем у подкласса Exception. Теперь мы можем использовать эти классы в коде и подкорректировать оба метода, construct() и write().

*/

class Conf2 {
	private $file;
	private $xml;
	private $lastmatch;

	function __construct($file) {
		$this->file = $file;
		if(!file_exists($file)) {
			throw new FileException("Файл '$file' не существует");
		}
		$this->xml = simplexml_load_file($file, null, LIBXML_NOERROR);
		if(!is_object($this->xml)) {
			throw new XmlException(libxml_get_last_error());
		}
		print gettype($this->xml);
		$matches = $this->xml->xpath("/conf");
		if(!count($matches)) {
			throw new ConfException("Корневой элемент сопf не найден.");
		}
	}

	function write() {
		if(!is_writeable($this->file)) {
			throw new FileException(" Фaйл '{$this->file}' недоступен для записи");
		}
		file_put_contents($this->file, $this->xml->asXML());
	}

	function get($str) {
		$matches = $this->xml->xpath("/conf/item[@name=\"$str\"]");
		if(count($matches)) {
			$this->lastmatch = $matches[0];
			return (string)$matches[0];
		}
		return null;
	}

	function set($key, $value) {
		if(!is_null($this->get($key))) {
			$this->lastmatch[0] = $value;
			return;
		}
		$conf = $this->xml->conf;
		$this->xml->addChild('item', $value)->addAttribute('name', $key);
	}
}

/*

Meтoд __construct() генерирует исключения типа XmlException, FileException или ConfException в зависимости от вида ошибки. которую он обнаружит. Обратите внимание на то, что методу simplexml_load_file() передается флажок LIBXML_NOERROR. Это блокирует выдачу предупреждений внутри класса и оставляет программисту свободу действий для их последующей обработки с помощью класса XmlException. Если обнаружится поврежденный ХМL-файл, то метод simplexml_load_file() уже не возвратит объект типа SimpleXMLElement. Благодаря классу XmlException в клиентском коде можно будет легко узнать причину ошибки, а с помощью
метода libxmlget_last_error() - все подробности этой ошибки.
Метод write() генерирует исключение типа FileException, если свойство $file указывает на файл, недоступный для записи.

Итак, мы установили, что мeтoд __construct() может генерировать одно из трех возможных исключений. Как мы можем этим воспользоваться? Ниже приведен пример кода, в котором создается экземпляр объекта Conf().
*/

class Runner {
	static function init() {
		try {
			$conf = new Conf(dirname(_FILE_) . "/conf01.xml");
			print "user: " . $conf->get('user') . "";
			print "host: " . $conf->get('host') . "";
			$conf->set("pass", "newpass");
			$conf->write();
		} catch (FileException $e) {
			// Файл не существует либо недоступен для записи
		} catch (XmlException $e) {
			// Поврежденный ХМL-файл
		} catch (ConfException $e) {
			// Некорректный формат ХМL-файла
		} catch (Exception $e) {
			// Ловушка : этот код не должен никогда вызываться
		}
	}
}


/*
В этом примере мы предусмотрели оператор catch для каждого типа класса ошибки. То, какой оператор будет вызван, зависит от типа сгенерированного исключения. При этом будет выполнен первый подходящий оператор. Поэтому помните: самый общий тип нужно размещать в конце, а самый специализированный - в начале списка операторов catch. Например, если бы вы разместили оператор catch для обработки исключения типа Exception перед операторами для обработки исключений типа XmlException и ConfException, ни один из них никогда не был бы вызван. Причина в том, что оба исключения относятся к типу Exception и поэтому будут соответствовать первому оператору.

Первый оператор catch (FileException) вызывается, если есть проблема с файлом конфигурации (если этот файл не существует или в него нельзя ничего записать).

Второй оператор catch (XmlException) вызывается, если происходит ошибка при синтаксическом анализе ХМL-файла (например, если какой-то элемент не закрыт).

Третий оператор catch (ConfException) вызывается, если корректный в плане формата ХМL-файл не содержит ожидаемый корневой элемент conf.

Последний оператор catch (Exception) не должен вызываться, потому что наши методы генерируют только три исключения, которые обрабатываются явным образом. Вообще, неплохо иметь такой оператор-ловушку на случай, если в процессе разработки понадобится
добавить в код новые исключения.

Преимущество этих уточненных операторов catch в том, что они позволяют применить к разным ошибкам различные механизмы восстановления или неудачного завершения. Например, вы можете прекратить выполнение программы, записать в журнал информацию об ошибке и продолжить выполнение или повторно сгенерировать исключение, как показано ниже.

*/

try {
	//...
} catch (FileException $e) {
	throw $e;
}

/*
Еще один вариант, которым можно воспользоваться, - сгенерировать новое исключение, которое будет перекрывать текущее. Это позволяет привлечь внимание к ошибке, добавить собственную контекстную информацию и в то же время сохранить данные, зафиксированные в исключении, которое обработала ваша программа. Более подробно об этом методе читайте в главе 15.

Но что произойдет, если исключение не будет обработано в клиентском коде? Тогда оно автоматически сгенерируется повторно, и его сможет обработать вызывающий код клиентской программы. Этот процесс будет продолжаться до тех пор, пока исключение не будет обработано либо его уже нельзя будет снова сгенерировать. Тогда произойдет неустранимая ошибка. Вот что произойдет, если в примере нашего кода не будет обработано ни одно исключение.

РНР Fatalerror:Uncaught exception 'FileException' with message 'file' nonexistent/not_there.xml 'does not exist' in.

Итак, генерируя исключение, вы заставляете клиентский код брать на себя ответственность за его обработку. Но это не отказ от ответственности. Исключение должно генерироваться, когда метод обнаруживает ошибку, но не имеет контекстной информации, чтобы правильно ее обработать. Метод write() в нашем примере знает, когда попытка сделать запись заканчивается неудачей и почему, но не знает, что с этим делать. Именно так и должно быть. Если бы мы сделали класс Conf более сведущим, чем он есть в настоящее время, он бы потерял свою универсальность и перестал бы быть повторно используемым.


Уборка за собой с помощью оператора finally

Сам факт, что в ход выполнения программы могут вмешаться внешние факторы в виде исключений, может привести к неожиданным проблемам. Например, после возникновения исключения в блоке try может не выполниться код очистки или любые другие важные действия. Как было сказано выше, при возникновении исключительной ситуации в блоке try управление программы передается первому подходящему блоку catch. В результате может не выполниться код, в котором закрывается подключение к базе данных или файлу, обновляется текущая информация о состоянии и т. п .

В качестве примера предположим, что в методе Runner::init() регистрируются все действия приложения. При этом в системный журнал записываются факт начала процесса инициализации, все ошибки, возникающие при работе приложения, а в самом конце - факт окончания процесса инициализации. Ниже приведен типичный упрощенный фрагмент кода, выполняющий эти действия.
*/

class Runner2 {
	static function init() {
		try {
			$fh = fopen("./log.txt", "a");
			fputs($fh, "Начало");
			$conf = new Conf(dirname(_FILE_) . "/conf.broken.xml");
			print "user: " . $conf->get('user') . "";
			print "host: " . $conf->get('host') . "";
			$conf->set("pass", "newpass");
			$conf->write();
			fputs($fh, "Конец");
			fclose($fh);

		} catch (FileException $e) {
			fputs($fh, "Файловая ошибка ");
		} catch (XmlException $e) {
			// Поврежденный ХМL-файл
		} catch (ConfException $e) {
			// Некорректный формат ХМL-файла
		} catch (Exception $e) {
			// Ловушка : этот код не должен никогда вызываться
		}
	}
}

/*
Здесь сначала открывается файл log.txt, после чего в него записываются данные, а затем вызывается код для конфигурирования приложения. В случае возникновения ошибки на данном этапе информация об этом записывается в файл журнала в блоке catch. Блок try завершается оператором записи в файл и закрытием этого файла. Разумеется, в случае возникновения исключительной ситуации эти действия выполнены не будут. При этом управление передается в соответствующий блок catch, и оставшаяся часть кода блока try выполнена не будет. Ниже показан фрагмент системного журнала при возникновении исключительной ситуации, связанной с файлами.

Начало
Файловая ошибка

Как видите, в журнале зафиксированы факт начала процесса инициализации приложения и файловая ошибка. Поскольку фрагмент кода, в котором выводится информация в журнал об окончании процесса инициализации, не был выполнен, соответственно, в файл журнала ничего записано не было.

На первый взгляд может показаться, что код последнего этапа записи в журнал нужно вынести за пределы блока try/catch. Однако такое решение нельзя назвать надежным. Дело в том, что при обработке исключительной ситуации в блоке catch может быть принято решение о возобновлении выполнения программы. При этом управление может быть передано в произвольное место программы, которое находится далеко за пределами блока try/catch. Кроме того, в блоке catch может быть сгенерировано повторное исключение либо вовсе завершена работа программы. Поэтому, чтобы помочь программистам корректно выйти из описанной выше ситуации, в РНР 5.5 был введен новый оператор - finally. Если вы знакомы с языком Java, наверняка вы уже с ним сталкивались. Несмотря на то что блок кода саtch вызывается только при возникновении исключительной ситуации заданного типа, блок кода finally вызывается всегда, независимо от того, возникло ли исключение при выполнении блока try.
Итак, для решения описанной выше проблемы мне нужно переместить код последнего этапа записи в журнал и закрытия файла в блок finally.
*/

class Runner3 {
	static function init() {
		$fh = fopen("./log.txt", "w");
		try {			
			fputs($fh, "Начало");
			$conf = new Conf(dirname(_FILE_) . "/conf.broken.xml");
			print "user: " . $conf->get('user') . "";
			print "host: " . $conf->get('host') . "";
			$conf->set("pass", "newpass");
			$conf->write();
		} catch (FileException $e) {
			// Файл недоступен для записи или не найден
			fputs($fh, "Файловая ошибка ");
			throw $e;
		} catch (XmlException $e) {
			fputs($fh, "Ошибка в коде xml");
			// Некорректный код xml
		} catch (ConfException $e) {
			fputs($fh, "Ошибка в файле конфигурации");
			// Некорректный тип ХМL-файла
		} catch (Exception $e) {
			fputs($fh, "Другая ошибка ");
			// Ловушка : этот код не должен никогда вызываться
		} finally {
			fputs($fh, "Конец");
			fclose($fh);
		}
	}
}

/*
Поскольку код последней записи в журнал и вызов функции fclose() помещены в блок finally, они будут выполняться всегда, даже в случае возникновения исключения FileException и повторной его генерации в блоке catch. Ниже приведен фрагмент журнала при возникновении исключения FileException.

Начало
Файловая ошибка
Конец


На заметку. Блок кода finallу запускается, если в блоке саtch будет повторно сгенерировано исключение либо будет выполнен оператор return, возвращающий значение в вызывающую программу. Если же в блоке try или catch будет вызвана функция die() или exit() для завершения программы, блок кода finally не запустится.


Завершенные классы и методы

Наследование открывает большие возможности для широкого поля действий в пределах иерархии класса. Вы можете переопределить класс или метод, чтобы вызов в клиентском методе приводил к совершенно разным результатам, в зависимости от типа объекта, переданного методу в качестве аргумента. Но иногда код класса или метода нужно зафиксировать, если предполагается, что в дальнейшем он не должен изменяться. Если вы создали необходимый уровень функциональности для класса и считаете, что его переопределение может только повредить идеальной работе программы, используйте ключевое слово final. Ключевое слово final позволяет положить конец наследованию. Для завершенного класса нельзя создать подкласс. А завершенный метод нельзя переопределить.

Давайте объявим класс завершенным.

final class Checkout {
	//...
}

А теперь попытаемся создать подкласс класса Checkout.

class IllegalCheckout extends Checkout {
	//...
}

Это приведет к ошибке.

Fatal error: Class IllegalCheckout may not inherit from final class (Checkout) in 

Мы можем несколько смягчить ситуацию, объявив завершенным только метод в классе Checkout, а не весь класс. Ключевое слово final должно стоять перед любыми другими модификаторами, такими как protected или static.

class Checkout {
	final function totalize() {
	// Вычисление итоговых данных
	}
}

Теперь мы можем создать подкласс класса Checkout, но любая попытка переопределить метод totalize() приведет к неустранимой ошибке.

class IllegalCheckout extends Checkout {
	final function totalize() {
		//Зафиксируем алгоритм расчета итоговых данных
	}
}

Fatal error: Cannot override final method Checkout::totalize() in

В хорошем объектно-ориентированном коде обычно во главу угла ставится строго определенный интерфейс. Но за этим интерфейсом могут скрываться разные реализации. Разные классы или сочетания классов могут соответствовать общим интерфейсам, но при этом вести себя по-разному в разных ситуациях. Объявляя класс или метод завершенным, вы тем самым ограничиваете эту гибкость. В некоторых случаях это выгодно, и мы рассмотрим такие случаи далее в книге. Но прежде чем объявлять что-либо завершенным, следует серьезно подумать. Действительно ли нет таких ситуаций, в которых переопределение было бы полезным? Конечно, вы всегда можете передумать, но внести изменения впоследствии может быть нелегко, например, если вы распространяете библиотеку для совместного использования. Поэтому будьте осторожны, используя ключевое слово final.



Работа с методами - перехватчиками

В РНР предусмотрены встроенные методы-перехватчики, которые могут перехватывать сообщения, посланные неопределенным (т.е. несушествующим) методам или свойствам. Это свойство называется также перегрузкой (overloading), но поскольку этот термин в Java и С++ означает нечто совершенно другое, я думаю, будет лучше использовать термин "перехват" (interception).

В РНР 5 поддерживается три встроенных метода-перехватчика. Как и в случае метода __construct(), вызов этих методов происходит неявно, когда удовлетворяются соответствующие условия. Эти методы описаны в табл. 4.2.

/*
Таблица 4.2. Методы-перехватчики

Метод                                       Описание

__get($property)                            Вызывается при обращении к неопределенному свойству

__set($property, $value)                    Вызывается, когда неопределенному свойству присваивается значение

__isset($property)                          Вызывается, когда функция isset() вызывается для неопределенного свойства

__unset($property)                          Вызывается, когда функция unset() вызывается для неопределенного свойства

__call($method, $arg_array)                 Вызывается при обращении к неопределенному нестатическому методу

__callStatic($method, $arg_array)           Вызывается при обращении к неопределенному статическому методу



Методы __get() и __set() предназначены для работы со свойствами, которые не были объявлены в классе (или его родителе).
Метод __get() вызывается, когда клиентский код пытается прочитать необъявленное свойство. Он вызывается автоматически с одним строковым аргументом, содержащим имя свойства, к которому клиентский код пытается получить доступ. Все, что вернет метод __get(), будет отослано обратно клиенту, как будто искомое свойство существует с этим значением. Рассмотрим короткий пример.

*/

class Person {
	function __get($property) {
		$method = "get{$property}";
		if(method_exists($this, $method)) {
			return $this->$method();
		}
	}

	function getName() {
		return "Иван";
	}

	function getAge() {
		return 44;
	}
}

/*
Когда клиентский код пытается получить доступ к неопределенному свойству, вызывается метод _get(), в котором перед именем переданного ему свойства добавляется строка "get". Затем полученная строка, содержащая новое имя метода, передается функции method_exists(). Этой функции передается также ссылка на текущий объект, для которого проверяется существование метода. Если метод существует, мы вызываем его и передаем возвращенное им значение клиентскому коду. Поэтому, если клиентский код запрашивает свойство $name
*/

echo "<br>";
$p = new Person();
print $p->name;

/*
Метод getName() вызывается неявно и выводится следующая строка 'Иван'.

Если же метод не существует, то ничего не происходит. Свойству, к которому пользователь пытается обратиться, присваивается значение NULL.
Метод __isset() работает аналогично методу __get(). Он вызывается после того, как в клиентском коде вызывается функция isset() и ей в качестве параметра передается имя неопределенного свойства. Рассмотрим пример расширения класса Person.
*/

function __isset($property) {
	$method = "get{$property}";
	return (method_exists($this, $method));
}

/*
А теперь предусмотрительный пользователь может проверить свойство, прежде чем работать с ним.
*/

if(isset($p->name)) {
	print $p->name;
}

/*
Метод __set() вызывается, когда клиентский код пытается присвоить значение неопределенному свойству. При этом передаются два аргумента: имя свойства и значение, которое клиентский код пытается присвоить. Затем вы можете решить, как работать с этими аргументами. Давайте продолжим расширение класса Person.
*/

class Person2 {
	private $_name;
	private $_age;

	function __set($property, $value) {
		$method = "set{$property}";
		if(method_exists($this, $method)) {
			return $this->$method($value);
		}
	}

	function setName($name) {
		$this->_name = $name;
		if(!is_null($name)) {
			$this->_name = strtoupper($this->_name);
		}
	}

	function setAge($age) {
		$this->_age = strtoupper($age);
	}
}

/*
В этом примере мы работаем с методами-установщиками (setter), а не с методами получателями (getter). Если пользователь попытается присвоить значение неопределенному свойству, то методу set() будут переданы имя этого свойства и присваиваемое ему значение. В методе set() проверяется, существует ли указанный метод, и если существует, то он вызывается. В результате мы можем отфильтровать присваиваемое свойству значение.


На заметку. Не забывайте, что в РНР-документации при описании имен методов и свойств часто используется статический синтаксис, чтобы было ясно, в каком классе они содержатся. Поэтому вы можете встретить ссылку на свойство Person::$name, даже если это свойство не объявлено как статическое и к нему на самом деле можно получить доступ через объект, имя которого отличается от Person.

Итак, если мы создаем объект типа Person, а затем пытаемся установить свойство Person::$name, то вызывается метод set(), потому что в этом классе не определено свойство $name. Методу передаются две строки, содержащие имя свойства и значение, которое мы хотим установить. И уже от нас зависит, что мы сделаем с этой информацией. В данном примере мы создаем новое имя метода, добавив перед именем свойства строку "set". Программа находит метод setName() и запускает его должным образом. Он преобразует входящую строку в символы верхнего регистра и сохраняет ее в реальном свойстве.

*/

$p = new Person2();
$p->name = "Иван";

/*
Реальному свойству $_name присваивается строка 'ИВАН'

Как и можно было ожидать, метод unset() является зеркальным отражением метода set(). Он вызывается в случае, когда функции unset() передается имя неопределенного свойства. Имя этого свойства и передается методу unset().
С полученной информацией можно делать все что угодно. В приведенном ниже примере значение null передается найденному результирующему методу тем же самым способом, который мы использовали при рассмотрении метода set().
*/

function __unset($property) {
	$method = "set{$property}";
	if(method_exists($this, $method)) {
		$this->$method(null);
	}
}

/*
Метод call(), вероятно, - самый полезный из всех методов-перехватчиков. Он вызывается, когда клиентский код обращается к неопределенному методу. При этом методу call() передаются имя несуществующего метода и массив, в котором содержатся все аргументы, переданные клиентом. Значение, возвращаемое методом call(), передается клиенту так, как будто оно было возвращено
вызванным несуществующим методом.

Метод call() может использоваться для делегирования. Делегирование - это механизм, посредством которого один объект может вызвать метод другого объекта.
Это чем-то напоминает наследование, когда дочерний класс вызывает метод, реализованный в родительском классе. В случае наследования взаимосвязь между родительским и дочерним классами фиксирована. Поэтому возможность изменить объект-получатель во время выполнения программы означает, что делегирование является более гибким, чем наследование. Чтобы лучше это понять, давайте проиллюстрируем все на примере. Рассмотрим простой класс, предназначенный для форматирования информации, полученной от класса Person.
*/

class PersonWriter {

	function writeName(Person3 $p) {
		print $p->getName() . "";
	}

	function writeAge(Person3 $p) {
		print $p->getAge() . "";
	}
}

/*
Конечно, мы можем создать подкласс от этого класса, чтобы выводить данные о классе Person различными способами. Вот реализация класса Person, в которой используются и объект PersonWriter, и метод __call().
*/

class Person3 {
	private $writer;

	function __construct(PersonWriter $writer) {
		$this->writer = $writer;
	}

	function __call($methodname, $args) {
		if(method_exists($this->writer, $methodname)) {
			return $this->writer->$methodname($this);
		}
	}

	function getName() {return "Иван";}
	function getAge() {return 44;}
}

/*
Здесь конструктору класса Person в качестве аргумента передается объект типа PersonWriter, ссылка на который сохраняется в переменной свойства $writer. В методе __call() используется значение аргумента $methodname и проверяется наличие метода с таким же именем в объекте PersonWriter, ссылка на который была сохранена в конструкторе. Если такой метод найден, его вызов делегируется объекту PersonWriter. При этом методу передается ссылка на текущий экземпляр объекта типа Person, которая хранится в псевдопеременной $this. Поэтому, если клиент вызовет несуществующий в классе Person метод
*/

echo "<br>";
$person = new Person3(new PersonWriter());
$person->writeName();
$person->writeAge();

/*
будет вызван метод  __call(). В нем определяется, что в объекте типа PersonWriter существует метод с именем writeName(), который и вызывается. Это позволяет избежать вызова делегированного метода вручную, как показано ниже.
*/

function writeName() {
	$this->writer->writeName($this);
}

/*
Таким образом, класс Person, как по волшебству, получил два новых метода класса PersonWriter. Хотя автоматическое делегирование избавляет вас от рутинной работы по однотипному кодированию вызовов методов, сам код становится сложным
для понимания. И если в вашей программе активно используется делегирование, то для внешнего мира создается динамический интерфейс, который не поддается рефлексии (исследованию состава класса во время выполнения программы) и не всегда с первого взгляда понятен программисту клиентского кода. Причина в том, что логика, лежащая в основе взаимодействия между делегирующим классом и целевым объектом, может быть непонятной. Ведь она скрыта в таких методах, как __call(), а не явно задана отношениями наследования или уточнениями типа аргументов методов. Методы-перехватчики имеют свою область применения,
но использовать их следует с осторожностью. И в классах, где используются эти методы, факт такого применения необходимо очень четко и ясно документировать.

К вопросам делегирования и рефлексии мы вернемся позже в данной книге. Методы-перехватчики __get() и __set() можно также использовать для поддержки составных свойств (composite properties). Они могут создать определенные удобства для программиста клиентского кода. В качестве примера давайте представим, что в классе Address сохраняется информация о номере дома и названии улицы. Поскольку в конечном итоге данные из этого класса будут сохранены в соответствующих полях базы данных, то такое разделение адреса на улицу и номер дома имеет определенный смысл. Однако в случае, если часто требуется неразделенная информация об адресе, содержащая в одной строке и номер дома. и название улицы, вам необходимо позаботиться о том, кто будет использовать ваш класс в своих программах. Ниже приведен пример класса, поддерживающий составное свойство Address::$streetaddress
*/

class Address {
	private $number;
	private $street;

	function __construct($maybenumber, $maybestreet=null) {
		if(is_null($maybestreet)) {
			$this->streetaddress = $maybenumber;
		} else {
			$this->number = $maybenumber;
			$this->street = $maybestreet;
		}
	}

	function __set($property, $value) {
		if(preg_match("/^(\d+.*?)[\s,]+(.+)$/", $value, $matches)) {
			$this->number = $matches[1];
			$this->street = $matches[2];
		} else {
			throw new Exception("Ошибка в адресе: '{$value}'");
		}
	}

	function __get($property) {
		if($property === "streetaddress") {
			return $this->number." ".$this->street;
		}
	}
}

echo "<br>";
$address = new Address("441Ь Bakers Street");
print "Адрес: ($address->streetaddress)";

echo "<br>";
$address = new Address(15, "Albert Mews");
print "Адрес: ($address->streetaddress)";

echo "<br>";
$address->streetaddress = "34, West 24th Avenue";
print "Адрес: ($address->streetaddress)";


/*
При попытке обращения к несуществующему свойству Address::$streetaddress будет вызван метод __call(). В нем проверяется имя составного свойства "streetaddress", которое мы должны поддерживать в классе. Перед тем как установить значения свойств $number и $street, мы должны убедиться, что переданный нам адрес соответствует ожидаемому шаблону и может быть корректно проанализирован.
После этого нужно извлечь значения свойств из строки адреса, которую передал пользователь. Для нашего примера я задал простое правило. Адрес может быть корректно проанализирован, если он начинается с цифры, после которой следует пробел или запятая, а затем - название улицы. Благодаря использованию обратных ссылок в регулярном выражении, после удачного анализа строки в массиве $matches будут находиться нужные мне данные, которые можно присвоить свойствам $numЬer и $street. Если же строка адреса проверку не прошла, в программе генерируется исключение. Поэтому, когда строка адреса наподобие "441Ь BakersStreet" присваивается свойству Address::$streetaddress, на самом деле будут присвоены значения свойствам $numЬer и $street, которые были выделены из этой строки. В этом можно убедиться с помощью функции print_r().
*/

echo "<br>";
$address = new Address("441Ь Bakers Street");
print_r($address);

// будет выведено: Address Object ( [number:Address:private] => 441Ь [street:Address:private] => Bakers Street )

/*
По сравнению с методом __set() метод __get() очень простой. При попытке доступа к свойству Address::$streetaddress будет вызван метод __get(). В моей реализации в нем сначала проверяется имя свойства "streetaddress", и, если оно совпадает, в вызывающую программу возвращается строка, составленная из двух значений свойств $numЬer и $street.


Определение методов деструктора

Как мы уже видели, при создании экземпляра объекта автоматически вызывается мeтoд __construct(). В РНР 5 также существует мeтoд __destruct(). Он вызывается непосредственно перед тем, как объект отправляется на "свалку", т.е ., я хочу сказать, перед тем как он удаляется из памяти. Вы можете использовать этот метод для выполнения завершающей очистки объекта, если это необходимо.

Например, предположим, что класс после получения специальной команды сохраняет данные объекта в базе данных. Тогда метод destruct() можно использовать для того, чтобы гарантированно сохранить данные объекта перед его удалением из памяти. Добавим деструктор в класс Person, как показано ниже.
*/


class Person4 {
	private $name;
	private $age;
	private $id;

	function __construct($name, $age) {
		$this->name = $name;
		$this->age = $age;
	}

	function setId($id) {
		$this->id = $id;
	}

	function __destruct() {
		if(!empty($this->id)) {
			// Сохраним данные объекта Person
			print "Сохранение объекта person ";
		}
	}
}

/*
Метод destruct() вызывается каждый раз, когда объект Person удаляется из памяти. Это происходит при вызове функции __unset(), которой передается ссылка на удаляемый объект, а также в случае, когда в текущем процессе не остается никаких
ссылок на наш объект. Поэтому, если мы создадим объект Person, а затем решим его уничтожить, то увидим, как на самом деле работает метод  __destruct().
*/
echo "<br>";
$person = new Person4("Иван", 44);
$person->setId(343);
print_r($person);
unset($person);

/*
Хотя такие приемы выглядят очень занимательно, следует добавить предостережение. Методы-перехватчики, такие как __call(), __destruct() и им подобные, иногда называют магическими. Если вы когда-либо читали произведения жанра "фэнтези", то, наверное, знаете, что магия - это не всегда хорошо. Магия случайна и непредсказуема. Магия нарушает правила. Магия приносит скрытые расходы. Например, в случае метода __destruct() может случиться так, что программист клиентского кода столкнется с неприятными сюрпризами. Задумайтесь, как работает класс Person: он делает запись в базу данных с помощью своего метода
destruct(). А теперь представьте, что начинающий разработчик решает использовать класс Person, не разобравшись, что к чему. Он не заметил мeтoд _destruct() и собирается создать ряд экземпляров объекта Person. Передавая значения конструктору, он назначает тайную и обидную кличку генерального директора свойству $name и устанавливает для свойства $age значение 150. Разработчик прогоняет тестовый сценарий несколько раз, используя красочные сочетания имени и возраста. А на следующее утро начальник вызывает его к себе в кабинет и просит объяснить, почему в базе данных содержатся оскорбительные данные в адрес служащих компании. Мораль сей басни такова: не доверяйте магии.


Копирование объектов с помощью метода __clone()

В РНР 4 копирование объекта выполнялось очень просто - достаточно было присвоить значение одной объектной переменной другой.

class CopyMe{};

$first = new CopyMe();
$second = $first;

В РНР 4 переменные $second и $first ссылаются на два разных объекта. Начиная с РНР 5 переменные $second и $first ссылаются на один объект.

Но эта простота часто служила источником множества ошибок, поскольку копии объекта случайно "размножались" при присвоении значений переменным, вызове методов и возврате объектов. Еще больше ухудшало ситуацию то, что не существовало способа протестировать две переменные, чтобы понять, относятся ли они к одному и тому же объекту. С помощью операторов эквивалентности можно было проверить идентичность значений всех полей у двух объектов (==) либо являются ли обе переменные объектами (===). Но в результате этих проверок нельзя было понять, указывают ли обе переменные на один и тот же объект.

В РНР 5 объекты всегда присваиваются и передаются по ссылке. Это означает, что если предыдущий пример запустить в РНР 5, переменные $first и $second будут содержать ссылки на один и тот же объект, а не на две его копии. И хотя в большинстве
случаев при работе с объектами это именно то, что нам нужно, будут ситуации, когда нам понадобится получить копию объекта, а не ссылку на объект.
В РНР 5 для этой цели предусмотрено ключевое слово clone. Оно применяется к экземпляру объекта и создает дополнительную копию.
*/

class CopyMe{};
$first = new CopyMe();
$second = clone $first;

/*
В РНР 5 и более поздних версиях переменные $second и $first ссылаются на два разных объекта

И здесь вопросы, касающиеся копирования объектов, только начинаются. Рассмотрим класс Person, который мы создали в предыдущем разделе. Стандартная копия объекта Person содержит идентификатор (свойство $id), который при реализации
полноценного приложения будет использоваться для нахождения нужной строки в базе данных. Если мы разрешим копировать это свойство, то получим два различных объекта, ссылающихся на один и тот же источник данных, причем, вероятно, не тот, который мы хотели, когда создавали копию. Изменение в одном объекте повлияет на другой и наоборот.

К счастью, при использовании перед объектом ключевого слова clone мы можем контролировать то, что копируется. Для этого следует реализовать специальный метод  __clone() (обратите внимание на два символа подчеркивания, с которых начинаются
имена всех встроенных методов) . Метод __clone() вызывается автоматически, когда для копирования объекта используется ключевое слово clone.
При реализации метода __clone() важно понимать контекст, в котором работает данный метод. Метод __clone() работает в контексте скопированного объекта а не исходного. Давайте добавим метод clone() к одной из версий нашего класса Person.

*/

class Person5 {
	private $name;
	private $age;
	private $id;

	function __construct($name, $age) {
		$this->name = $name;
		$this->age = $age;
	}

	function setId($id) {
		$this->id = $id;
	}

	function __clone() {
		$this->id = 0;
	}
}


/*
Когда оператор clone вызывается для объекта типа Person, создается его новая поверхностная (shallow) копия, и для нее вызывается метод clone(). Это означает, что все изменения значений свойств, выполняемые в методе clone(), отразятся
только на новой копии объекта. Старые значения, полученные из исходного объекта, будут затерты. В данном случае мы гарантируем, что свойство $id скопированного объекта устанавливается равным нулю.
*/
echo "<br>";
$person = new Person5("Петр", 44);
$person->setId(343);
$person2 = clone $person;
print_r($person);
echo "<br>";
print_r($person2);

/*
Поверхностное копирование гарантирует, что значения элементарных свойств будут скопированы из старого объекта в новый. Однако при этом будут скопированы и ссылки на другие объекты, которые бьли присвоены свойствам. Возможно, это не совсем то, что вы хотите, когда клонируете объект. Предположим, мы добавим к объекту Person свойство-объект Account. В этом объекте хранятся данные о состоянии счета, которые мы тоже хотим скопировать в клонированный объект. Однако при этом мы не хотим, чтобы в обоих объектах Person сохранялись ссылки на один и тот же счет.
*/
class Account {
	public $balance;

	function __construct($balance) {
		$this->balance = $balance;
	}
}

class Person6 {
	private $name;
	private $age;
	private $id;
	public $account;

	function __construct($name, $age, Account $account) {
		$this->name = $name;
		$this->age = $age;
		$this->account = $account;
	}

	function setId($id) {
		$this->id = $id;
	}

	function __clone() {
		$this->id = 0;
	}
}

echo "<br>";
$person = new Person6("Иван", 44, new Account(200));
$person->setId(343);
$person2 = clone $person;

//Добавим $person немного денег
$person->account->balance += 10;

//Это изменение увидит и $person2
print $person2->account->balance;

/*
Объектная переменная $person, которую мы сделали общедоступной ради компактности, содержит ссылку на объект типа Account. Как вы знаете, мы обычно ограничиваем доступ к свойству, создавая в случае необходимости метод доступа. Когда создается клон, он содержит ссылку на тот же самый объект Account, на который ссылается и $person. Мы демонстрируем это, добавляя немного денег к балансу объекта Account переменной $person, а затем выводя ее значение через переменную $person2. Если мы не хотим, чтобы после выполнения операции клонирования в новом объекте осталась ссылка на старое свойство-объект, последнее нужно клонировать явно в методе clone().
*/

function __clone() {
	$this->id = 0;
	$this->account = clone $this->account;
}

/*

О пределение строковых значений для объектов 

Еще одна функция, введенная в РНР 5 явно под влиянием Java, - метод _toString(). До выхода версии РНР 5.2 при печати объекта с помощью кода 

class StringThing {}

$st = new StringThing();
print $st;

выводилась следующая строка:
Object id #1

А начиная с версии РНР 5.2 этот код вызовет следующую ошибку:

Catchable fatal error: Object of class StringThing could not be converted to string in 


Реализовав метод __toString(), вы можете контролировать то, какую информацию будут выводить объекты при печати. Метод __toString() должен возвращать строковое значение. Этот метод вызывается автоматически, когда объект передается функции print или echo, а возвращаемое им строковое значение будет выведено на экран. Давайте добавим версию метода toString() к минимальной реализации класса Person.
*/

class Person7 {
	function getName() {return "Иван";}
	function getAge() {return 44;}

	function __toString() {
		$desc = $this->getName();
		$desc .= " (возраст " . $this->getAge() . " лет)";
		return $desc;
	}
}

// Теперь при печати объекта Person

echo "<br>";
$person = new Person7();
print $person;

// получим следующее: Иван (возраст 44 лет)

/*
Метод __toString() особенно полезен для записи информации в журнальные файлы и для выдачи сообщений об ошибках, а также для классов, основная задача которых - передавать информацию. Например, при выводе на печать объекта типа Exception можно выдавать краткий отчет о происшедших исключениях, реализовав в нем метод toString().


Функции обратного вызова , анонимные функции и механизм замыканий

Несмотря на то что анонимные функции относятся не только к области объектно-ориентированного программирования, они настолько полезны, что я не мог их здесь не упомянуть. Все дело в том, что они активно используются в объектно-ориентированных приложениях наряду с функциями обратного вызова. Более того, в этой области за последнее время было сделано несколько довольно интересных открытий.
Для начала давайте определим несколько классов.
*/

class Product {
	public $name;
	public $price;

	function __construct($name, $price) {
		$this->name = $name;
		$this->price = $price;
	}
}

class ProcessSale {
	private $callbacks;

	function registerCallback($callback) {
		if(! is_callable($callback)) {
			throw new Exeption("Функция обратного вызова - невызываемая!");
		}

		$this->callbacks[] = $callback;
	}

	function sale($product) {
		print "{$product->name}: обрабатывается... ";
		foreach ($this->callbacks as $callback) {
			call_user_func($callback, $product);
		}
	}
}

/*
Этот код предназначен для запуска нескольких функций обратного вызова. В нем определены два класса. В классе Product просто сохраняются значения свойств $name и $price. Для компактности я объявил их открытыми. Не забудьте в реальном проекте
сделать их закрытыми или защищенными и создать для этих свойств методы доступа. В классе ProcessSale определены два метода. Методу registerCallback() передается обычная скалярная переменная безо всяких уточнений. После ее проверки она добавляется в массив функций обратного вызова $callbacks. Процесс тестирования выполняется с помощью встроенной функции is_callable(). В результате гарантируется, что методу registerCallback() будет передано имя функции, которую можно вызвать с помощью таких функций, как call_user_func() или array_walk().
Методу sale() передается объект типа Product. Метод выводит об этом информацию и затем в цикле выполняет перебор элементов массива $callback. Каждый элемент вместе с объектом типа Product передается функции calluserfunc(), которая, собственно, и вызывает код, написанный пользователем. Все приведенные ниже примеры будут работать в контексте одной инфраструктуры.

Чем же так полезны функции обратного вызова? Они позволяют в процессе выполнения программы добавлять компоненту новые функциональные возможности, которые напрямую не бьши связаны с его первоначальной основной функциональностью.
Предусмотрев в объекте работу с функциями обратного вызова, вы тем самым позволите другим программистам расширять функциональность вашего кода, причем при таких обстоятельствах, о которых раньше вы даже и не догадывались. Представьте себе, например, что через какое-то время пользователь класса ProcessSale захочет создать журнал продаж. Если у пользователя будет доступ к исходному коду класса, он может добавить код фиксации сделок прямо в метод sale(). Однако это не всегда удачное решение. Если этот пользователь не является владельцем пакета, в котором определен класс ProcessSale, то все его исправления будут затерты, когда выйдет его обновленная версия. И даже если он является владельцем пакета, все равно, добавлять в метод sale() дополнительные ветки кода, решающие случайные задачи, неразумно. В конечном итоге это приведет к изменению зоны ответственности класса и потенциально может снизить возможность его повторного использования в других проектах. Я еще вернусь к этой теме в других главах книги.

Несмотря на это, по счастливой случайности, я заложил в класс ProcessSale возможность обратного вызова. Ниже я создал функцию обратного вызова, которая фиксирует все сделки в журнале продаж.
*/

$logger = create_function('$product', 'print "Записываем... ({$product->name}) ";');
$processor = new ProcessSale();
$processor->registerCallback($logger);

$processor->sale(new Product("Туфли", 6));
echo "<br>";
$processor->sale(new Product("Кофе", 6));

/*

Здесь для создания функции обратного вызова я воспользовался функцией create_function(). Как видите, ей передаются два параметра. Сначала указывается список параметров функции, а затем - тело самой функции. В результате у нас получилась конструкция, которую часто называют анонимной, поскольку при создании мы не присвоили ей имя, как в обычных функциях. Вместо этого ссылка на вновь созданную функцию сохраняется в переменной, которую затем можно передать в качестве параметра другим функциям и методам. Собственно, это я и сделал в приведенном выше фрагменте кода. Я сохранил ссылку на анонимную
функцию в переменной $logger, которую затем передал в качестве параметра методу ProcessSale::registerCallback(). В конце листинга я создал пару объектов, описывающих товары, и передал их по очереди методу sale(). О том, что произойдет дальше, вы уже, наверное, догадались. Каждая сделка по продаже будет обработана (на самом деле будет выведено обычное сообщение о товаре), после чего будут вызваны все установленные функции обратного вызова, как показано ниже.

Иван (возраст 44 лет)Туфли: обрабатывается... Записываем... (Туфли) 
Кофе: обрабатывается... Записываем... (Кофе)

Давайте еще раз проанализируем пример кода с функцией create_function(). Вы обратили внимание на то, насколько уродливо он выглядит? При помещении выполняемого кода в строку всегда возникает головная боль. Для начала вам нужно выполнить экранирование всех символов '$' и '?', которые встречаются в тексте программы. Более того, по мере роста тела функции обратного вызова ее и в самом деле будет все труднее и труднее проанализировать и понять. Было бы просто замечательно,
если бы существовал какой-нибудь более элегантный способ создания таких функций. Начиная с РНР 5.3 такой способ существует! Теперь вы можете просто объявить функцию, как обычно, а затем присвоить ссылку на нее переменной. И все это - в одном операторе! Ниже приведен предыдущий пример, в котором использован новый синтаксис.
*/

$loger2 = function($product) {
	print " Записываем ({$product->name})";
};
// важно после фигурной скобки стоит ; (точка с запятой)
$processor = new ProcessSale();
$processor->registerCallback($loger2);

$processor->sale(new Product("Туфли", 6));

echo "<br>";

$processor->sale(new Product("Кофе", 6));

echo "<br>";

/*
Единственное отличие здесь заключается в способе создания переменной, ссылающейся на анонимную функцию. Как видите, этот код намного понятнее. Я указал в операторе присваивания ключевое слово function и не задал имя функции. Обратите внимание на то, что, поскольку в операторе присваивания используется встроенная функция, в конце блока нужно обязательно поместить точку с запятой. Конечно, если ваш код должен работать в одной из предыдущих версий РНР, вам придется продолжать использовать уродливый синтаксис с функцией create function(). Результат работы нового фрагмента кода ничем не будет отличаться от предыдущего.

Само собой разумеется, что функции обратного вызова не обязательно должны быть анонимными. В качестве такой функции вы смело можете использовать имя обычной функции или даже ссылку на метод какого-либо объекта. Ниже приведен пример.

*/

class Mailer {
	function doMail($product) {
		print "Упаковываем ({$product->name})";
	}
}

$processor = new ProcessSale();
$processor->registerCallback(array(new Mailer(), "doMail"));

$processor->sale(new Product("Туфли", 6));
echo "<br>";
$processor->sale(new Product("Кофе", 6));

/*
Здесь я создал новый класс Mailer, содержащий единственный метод doMail(). Этому методу передается объект типа Product, о котором метод выводит сообщение. При вызове метода registerCallback() я передал ему в качестве параметра массив, а не ссылку на функцию обратного вызова, как это было раньше. Первым элементом этого массива является объект типа Mailer, а вторым - строка, содержащая имя метода, который мы хотим вызвать. Помните, что в методе registerCallback() с помощью
функции is_callable() выполняется проверка аргумента на предмет того, можно ли его вызвать? Данная функция достаточно интеллектуальна и распознает массивы подобного вида. Поэтому при указании функции обратного вызова в виде массива в первом элементе такого массива должен находиться объект, содержащий вызываемый метод, а имя этого метода помещается в виде строки во второй элемент массива. Таким образом, мы успешно прошли проверку типа аргумента, и вот что выведет программа в результате.

Туфли: обрабатывается... Упаковываем (Туфли)
Кофе: обрабатывается... Упаковываем (Кофе)

Разумеется, что анонимную функцию можно вернуть из метода, как показано ниже.
*/

class Totalizer {
	static function warnAmount() {
		return function($product) {
			if($product->price > 5) {
				print "покупается дорогой товар: {$product->price}";
			}
		};
	}
}

$processor = new ProcessSale();
$processor->registerCallback(Totalizer::warnAmount());

/*
В этом примере нет ничего интересного, кроме того, что метод warnAmount() используется в качестве фабрики анонимной функции. Тем не менее подобная структура позволяет мне делать нечто гораздо большее, чем просто генерировать анонимную
функцию. Она позволяет мне воспользоваться преимуществами механизма замыкания (closures). В анонимной функции нового типа могут использоваться переменные, объявленные в другой анонимной функции, находящейся в родительской области видимости. Данная концепция очень сложна, чтобы понять ее сразу.

Вкратце это можно объяснить так, как будто анонимная функция запоминает контекст, в котором она была создана. Предположим, я хочу сделать так, чтобы метод Totalizer::warnArnount() выполнял следующее. Во-первых, я хочу, чтобы ему можно было передавать пороговое значение стоимости товаров. Во-вторых, я хочу, чтобы он подсчитывал стоимость (т.е. сумму цен) проданного товара. И когда стоимость проданного товара превысит установленный порог, функция должна выполнить некоторые
действия (в нашем случае, как вы уже можете догадаться, она просто выведет соответствующее сообщение). Чтобы анонимная функция могла воспользоваться переменными, определенными в родительской области видимости, используется ключевое слово use, как показано в примере ниже.
*/

class Totalizer2 {
	static function warnAmount($amt) {
		$count = 0;
		return function($product) use ($amt, &$count) {
			$count += $product->price;
			print "сумма: $count . <br>";

			if($count > $amt) {
				print "Продано товаров на сумму: {$count}";
			}
		};
	}
}

$processor = new ProcessSale();
$processor->registerCallback(Totalizer2::warnAmount(8));
echo "<br>";
$processor->sale(new Product("Туфли", 6));
$processor->sale(new Product("Кофе", 6));

/*
В директиве use анонимной функции, которая возвращается методом Totalizer::warnAmount(), указаны две переменные. Первая из них - это $amt, которая является аргументом, переданным методу warnAmount(). Вторая - замкнутая переменная $count. Она объявлена в теле метода warnArnount(), и начальное ее состояние равно нулю. Обратите внимание на то, что перед именем переменной $ count в директиве use я указал символ амперсанда '&'. Это означает, что данная переменная будет передаваться в анонимную функцию по ссьmке, а не по значению. Дело в том, что в теле анонимной функции я добавляю к ней цену товара и затем сравниваю новую сумму со значением переменной $amt. Если будет достигнуто пороговое значение, выводится соответствующее сообщение, как показано ниже.

Туфли: обрабатывается... сумма: 6 . 
Кофе: обрабатывается... сумма: 12 . 
Продано товаров на сумму: 12


В этом примере было показано, что значение переменной $count сохраняется между вызовами функции обратного вызова. Обе переменные, и $count и $amt , остаются связанными с этой функцией, поскольку они указаны в контексте ее объявления
и перечислены в директиве use.


Резюме
В этой главе мы попытались осветить тему более сложных объектно-ориентированных возможностей РНР. С некоторыми из них вы еще будете встречаться по мере чтения книги. В частности, мы будем часто возвращаться к абстрактным классам, исключениям и статическим методам.
В следующей главе мы немного отойдем от описания встроенных возможностей объектов и рассмотрим классы и функции, предназначенные для облегчения работы с объектами.
*/

стр 114
?>